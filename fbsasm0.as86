; by pts@fazekas.hu at Mon Nov 25 20:19:11 CET 2024
;
; This is a subset of the source code of fasm 1.30 (with some CPU
; instructions, `format MZ' and `format PE' removed), ported to as86 0.0.0
; (1991-11-29) syntax, for Linux i386 only. It's useful for bootstrapping
; fasm. See also fbsasm.as86, it needs as86 >=0.0.7.
;
; Works with as86 0.0.0 .. 0.0.8. It doesn't work with as86 0.0.9 .. 0.12.0
; because of the memory offset calculation bug, and `address out of bounds'
; errors. It is unknown whether it works with as86 0.12.4 .. 0.15.6. It
; works with as86 0.16.0 .. 0.16.21.
;
; as86 0.0.9 .. 0.12.0 fail to compile it with a bunch of `address out of
; bounds' errors in loop, loopnz and jecxz instructions.
;
; as86 0.0.9 .. 0.12.0 have a code generation bug: memory offset
; calculations are incorrect when -j is used, org is specified (even org 0),
; and as86 autogenerated a longer-than-8-bit conditional jump instruction.
; Example:
;
;   org 0
;   use32
;   jc here  ; Incorrect offset is generated for here.
;   .space 0x80  ; Prevent generation of a `jc short'.
;   here:
;   mov eax, here  ; Incorrect offset is generated for here as well.
;
; as86 built with `-DBIGBUFFER=0' limits input line length to 256 bytes
; (`#define LINLEN 256'), hence the lots of consecutive semicolons below.
;
; as86 0.0.0   was released in https://mirror.math.princeton.edu/pub/oldlinux/Linux.old/bin/as86.src.tar.Z and as86.tar.Z (as precompiled Linux i386 a.out executable program) on 1991-11-29
; as86 0.0.5   was released in Dev86-0.0.5.tar.gz      on 1996-03-24, with last file change to as86 on 1996-01-08; maybe the DOS version doesn't work (from the Changes file: (+ other machines where sizeof(char*) != sizeof(int))); macros are broken;;;;;;;;; command-line syntax is different (-s etc.)
; as86 0.0.6   was released in Dev86-0.0.6.tar.gz      on 1996-05-31, with last file change to as86 on 1996-03-31; maybe the DOS version doesn't work (from the Changes file: (+ other machines where sizeof(char*) != sizeof(int))); macros are broken
; as86 0.0.7   was released in Dev86-0.0.7.tar.gz      on 1996-09-03, with last file change to as86 on 1996-08-04; maybe the DOS version doesn't work (from the Changes file: (+ other machines where sizeof(char*) != sizeof(int)))
; as86 0.0.8   was released in Dev86src-0.0.8.tar.gz   on 1996-11-03, with last file change to as86 on 1996-10-26; maybe the DOS version doesn't work (from the Changes file: (+ other machines where sizeof(char*) != sizeof(int)))
; as86 0.0.9   was released in Dev86src-0.0.9.tar.gz   on 1996-12-01, with last file change to as86 on 1996-12-01; maybe the DOS version doesn't work (from the Changes file: (+ other machines where sizeof(char*) != sizeof(int)))
; as86 0.0.10  was released in Dev86src-0.0.10.tar.gz  on 1997-01-19, with last file change to as86 on 1997-01-02
; as86 0.0.11  was released in Dev86src-0.0.11.tar.gz  on 1997-03-03, with last file change to as86 on 1997-02-01; fbsasm.as86 also tested with the as86.exe precompiled for DOS 8086
; as86 0.12.0  was released in Dev86src-0.12.0.tar.gz  on 1997-05-09; fbsasm.as86 also tested with the as86.exe precompiled for DOS 8086
; as86 0.16.2  was released in Dev86dos-0.16.2.zip     on 2002-03-20; fbsasm.as86 also tested with the as86.exe precompiled for DOS 8086
; as86 0.16.21 was released in Dev86src-0.16.21.tar.gz on 2014-03-14
;
; Compile with: as86-0.0.0 -w -j -s fbsasm0.sym -b fbsasm0.bs8 fbsasm0.as86 && perl -e 'die if(read(STDIN,$_,10)or 0)!=10 or!s@^(?:\0..\0\0)?(?=\x7fELF\x01)@@s;print;print while<STDIN>' <fbsasm0.bs8 >fbsasm && chmod +x fbsasm && echo OK
; Compile with: ln -sf fbsasm.as86 fbsasm.as8 && kvikdos tools/as860162.exe -s fbsasm.sym -b fbsasm fbsasm.as8 && && chmod +x fbsasm
;
; The post-processing with Perl to remove the fist 5 bytes of fbsasm0.bs8 is
; needed only by as86 <= 0.0.6. It also adds 5 trailing bytes (\xff\0\0\0),
; but we use skip_5_bytes below to work around that.
;
; The `-s fbsasm0.sym' argument above is needed only by as86 >=0.0.7.
; Without that, as86 would add NUL bytes to the beginning, as many as the
; `org' value.
;
; Macros have been expanded, because macro definitions don't seem to work at
; all in as86 0.0.0 .. 0.0.7. And thus lines in fbsasm0.as86 don't
; correspond to lines in fbsasm.nasm anymore.
;
; Backslash within "..." has no special meaning in as86 0.0.0, but it has
; in as86 >=0.0.7.
;

; flat assembler 0.37 source, fasm.asm
; Copyright (c) 1999-2002, Tomasz Grysztar
; All rights reserved.

	program_base equ 0x700000  ; NASM 0.95 doesn't support `program_base equ 0x700000' with `org program_base'.

	org	program_base
	use32
	;use32 386  ; True as86 0.0.5 doesn't support it.

;	macro	align value { rb (value-1) - ($ + value-1) mod value }

file_header:
	db 0x7f
	.ascii  "ELF"
	db 1,1,1
file_header2: .space file_header+0x10-file_header2
	dw	2,3
	dd	1,start
	dd	program_header-file_header,0,0
	dw	program_header-file_header,0x20,1,0x28,0,0

program_header:
	dd	1,0,program_base,0
	dd	prebss-file_header,program_end-bss+prebss-file_header,7,0x1000

start:

	mov	esi,_logo
	call	display_string

	pop	eax
	cmp	eax,3
	jne	information
	pop	eax
	pop	dword [input_file]
	pop	dword [output_file]

	call	init_memory

	mov	edi,characters
	mov	ecx,0x100
	xor	al,al
      make_characters_table:
	stosb
	inc	al
	loop	make_characters_table
	mov	esi,characters+'a
	mov	edi,characters+'A
	mov	ecx,26
	rep
	movsb  ; rep* instructions and other prefixes must be in their own lines.
	mov	edi,characters
	mov	esi,symbol_characters+1
	movzx	ecx,byte [esi-1]
	xor	ebx,ebx
      convert_table:
	lodsb
	mov	bl,al
	mov	byte [edi+ebx],0
	loop	convert_table

	push	eax
	push	eax  ; alloca(8) for the gettimeofday buffer.
	mov	eax,78  ; SYS_gettimeofday.
	mov	ebx,esp
	xor	ecx,ecx
	int	0x80
	mov	eax,dword [esp]
	mov	ecx,1000
	mul	ecx
	mov	ebx,eax
	mov	eax,dword [esp+4]
	div	ecx
	pop	ecx
	pop	ecx  ; Free the gettimeofday buffer.
	add	eax,ebx
	mov	dword [start_time],eax

	call	preprocessor
	call	parser
	call	assembler

	movzx	eax,byte [current_pass]
	inc	al
	call	display_number
	mov	esi,_passes_suffix
	call	display_string
	push	eax
	push	eax  ; alloca(8) for the gettimeofday buffer.
	mov	eax,78  ; SYS_gettimeofday.
	mov	ebx,esp
	xor	ecx,ecx
	int	0x80
	mov	eax,dword [esp]
	mov	ecx,1000
	mul	ecx
	mov	ebx,eax
	mov	eax,dword [esp+4]
	div	ecx
	pop	ecx
	pop	ecx  ; Free the gettimeofday buffer.
	add	eax,ebx
	sub	eax,dword [start_time]
	jnc	time_ok
	add	eax,3600000
      time_ok:
	xor	edx,edx
	mov	ebx,100
	div	ebx
	or	eax,eax
	jz	display_bytes_count
	xor	edx,edx
	mov	ebx,10
	div	ebx
	push	edx
	call	display_number
	mov	dl,'.
	call	display_character
	pop	eax
	call	display_number
	mov	esi,_seconds_suffix
	call	display_string
      display_bytes_count:
	mov	eax,dword [written_size]
	call	display_number
	mov	esi,_bytes_suffix
	call	display_string
	xor	al,al
	jmp	exit_program

information:
	mov	esi,_usage
	call	display_string
	mov	al,1
	jmp	exit_program

;%include 'system.inc'

; flat assembler 0.37 source, system.inc
; Copyright (c) 1999-2002, Tomasz Grysztar
; All rights reserved.

O_ACCMODE  equ 00003
O_RDONLY   equ 00000
O_WRONLY   equ 00001
O_RDWR	   equ 00002
O_CREAT    equ 00100
O_EXCL	   equ 00200
O_NOCTTY   equ 00400
O_TRUNC    equ 01000
O_APPEND   equ 02000
O_NONBLOCK equ 04000

S_ISUID    equ 04000
S_ISGID    equ 02000
S_ISVTX    equ 01000
S_IRUSR    equ 00400
S_IWUSR    equ 00200
S_IXUSR    equ 00100
S_IRGRP    equ 00040
S_IWGRP    equ 00020
S_IXGRP    equ 00010
S_IROTH    equ 00004
S_IWOTH    equ 00002
S_IXOTH    equ 00001

init_memory:
	xor	ebx,ebx
	mov	eax,45  ; SYS_brk.
	int	0x80
	mov	dword [additional_memory],eax
	;mov	ebx,syscall_buffer
	;mov	eax,116  ; SYS_sysinfo. We are interested only the sysinfo.freeram field ([syscall_buffer+0x14]), but on modern Linux it's not bytes anymore (see mem_unit in sysinfo(2)), so it's meaningless below.
	;int	0x80
	;mov dword [available_memory],0x100000  ; Hardcode allocating maximum 1 MiB. 1 MiB enough, but 0.75 MiB is not enough to compile fasm 1.30.
	mov dword [available_memory],0x280000  ; Hardcode allocating maximum 2.5 MiB. 1 MiB enough, but 0.75 MiB is not enough to compile fasm 1.30. 2.5 MiB is enough to compile fasm 1.73.32.
    allocate_memory:
	mov	ebx,dword [additional_memory]
	add	ebx,dword [available_memory]
	mov	eax,45  ; SYS_brk.
	int	0x80
	mov	dword [memory_end],eax
	sub	eax,dword [additional_memory]
	jz	not_enough_memory
	shr	eax,3
	add	eax,dword [additional_memory]
	mov	dword [additional_memory_end],eax
	mov	dword [memory_start],eax
	ret
    not_enough_memory:
	shr	dword [available_memory],1
	cmp	dword [available_memory],0x4000
	jb	out_of_memory
	jmp	allocate_memory

exit_program:
	movzx	ebx,al
	mov	eax,1  ; SYS_exit.
	int	0x80

open:
	push	edx
	push	esi
	push	edi
	push	ebp
	mov	ebx,edx
	mov	eax,5  ; SYS_open.
	mov	ecx,O_RDONLY
	xor	edx,edx
	int	0x80
	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	test	eax,eax
	js	file_error
	mov	ebx,eax
	clc
	ret
    file_error:
	stc
	ret
create:
	push	edx
	push	esi
	push	edi
	push	ebp
	mov	ebx,edx
	mov	eax,5  ; SYS_open.
	mov	ecx,O_CREAT+O_TRUNC+O_WRONLY
	mov	edx,S_IRUSR+S_IWUSR+S_IRGRP
	int	0x80
	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	test	eax,eax
	js	file_error
	mov	ebx,eax
	clc
	ret
close:
	mov	eax,6  ; SYS_close.
	int	0x80
	ret
read:
	push	ecx
	push	edx
	push	esi
	push	edi
	push	ebp
	mov	eax,3  ; SYS_read.
	xchg	ecx,edx
	int	0x80
	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	pop	ecx
	test	eax,eax
	js	file_error
	cmp	eax,ecx
	jne	file_error
	clc
	ret
write:
	push	edx
	push	esi
	push	edi
	push	ebp
	mov	eax,4  ; SYS_write.
	xchg	ecx,edx
	int	0x80
	pop	ebp
	pop	edi
	pop	esi
	pop	edx
	test	eax,eax
	js	file_error
	clc
	ret
lseek:
	mov	ecx,edx
	xor	edx,edx
	mov	dl,al
	mov	eax,19  ; SYS_lseek.
	int	0x80
	clc
	ret

display_string:
	push	ebx
	mov	edi,esi
	mov	edx,esi
	or	ecx,-1
	xor	al,al
	repne
	scasb
	neg	ecx
	sub	ecx,2
	mov	eax,4  ; SYS_write.
	mov	ebx,1
	xchg	ecx,edx
	int	0x80
	pop	ebx
	ret
display_block:
	push	ebx
	mov	eax,4  ; SYS_write.
	mov	ebx,1
	mov	edx,ecx
	mov	ecx,esi
	int	0x80
	pop	ebx
	ret
display_character:
	push	ebx
	mov	[character],dl
	mov	eax,4  ; SYS_write.
	mov	ebx,1
	mov	ecx,character
	mov	edx,ebx
	int	0x80
	pop	ebx
	ret
display_number:
	push	ebx
	mov	ecx,1000000000
	xor	edx,edx
	xor	bl,bl
      display_loop:
	div	ecx
	push	edx
	cmp	ecx,1
	je	display_digit
	or	bl,bl
	jnz	display_digit
	or	al,al
	jz	digit_ok
	not	bl
      display_digit:
	mov	dl,al
	add	dl,0x30
	push	ebx
	push	ecx
	call	display_character
	pop	ecx
	pop	ebx
      digit_ok:
	mov	eax,ecx
	xor	edx,edx
	mov	ecx,10
	div	ecx
	mov	ecx,eax
	pop	eax
	or	ecx,ecx
	jnz	display_loop
	pop	ebx
	ret

fatal_error:
	mov	esi,error_prefix
	call	display_string
	pop	esi
	call	display_string
	mov	esi,error_suffix
	call	display_string
	mov	al,0xFF
	jmp	exit_program
assembler_error:
	call	flush_display_buffer
	mov	ebx,dword [current_line]
      find_error_home:
	test	byte [ebx+7],0x80
	jz	error_home_ok
	mov	ebx,[ebx+8]
	jmp	find_error_home
      error_home_ok:
	mov	esi,[ebx]
	call	display_string
	mov	esi,line_number_start
	call	display_string
	mov	eax,[ebx+4]
	call	display_number
	mov	dl,']
	call	display_character
	cmp	ebx,dword [current_line]
	je	line_number_ok
	mov	dl,0x20
	call	display_character
	mov	esi,dword [current_line]
	mov	esi,[esi]
	movzx	ecx,byte [esi]
	inc	esi
	call	display_block
	mov	esi,line_number_start
	call	display_string
	mov	esi,dword [current_line]
	mov	eax,[esi+4]
	and	eax,0x7FFFFFFF
	call	display_number
	mov	dl,']
	call	display_character
      line_number_ok:
	mov	esi,line_data_start
	call	display_string
	mov	esi,ebx
	mov	edx,[esi]
	call	open
	mov	al,2
	xor	edx,edx
	call	lseek
	mov	edx,[esi+8]
	sub	eax,edx
	push	eax
	xor	al,al
	call	lseek
	mov	ecx,[esp]
	mov	edx,dword [memory_start]
	call	read
	call	close
	pop	ecx
	mov	esi,dword [memory_start]
      get_line_data:
	mov	al,[esi]
	cmp	al,0xA
	je	display_line_data
	cmp	al,0xD
	je	display_line_data
	cmp	al,0x1A
	je	display_line_data
	or	al,al
	jz	display_line_data
	inc	esi
	loop	get_line_data
      display_line_data:
	mov	ecx,esi
	mov	esi,dword [memory_start]
	sub	ecx,esi
	call	display_block
	mov	esi,lf
	call	display_string
	mov	esi,error_prefix
	call	display_string
	pop	esi
	call	display_string
	mov	esi,error_suffix
	call	display_string
	jmp	exit_program

character: db 0,0

error_prefix: .ascii "error: "
	db 0
error_suffix: db '.
lf: db 10  ; .ascii "\n"
	db 0
line_number_start: .ascii " ["
	db 0
line_data_start: db 0x3a, 10  ; .ascii ":\n"
	db 0

;%macro dm 1  ; We use `.asciz' instead.
;  db %1, 0
;%endm

;%include '../version.inc'

; flat assembler  version 1.30
; Copyright (c) 1999-2002, Tomasz Grysztar
; All rights reserved.
;
; This programs is free for commercial and non-commercial use as long as
; the following conditions are aheared to.
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are
; met:
;
; 1. Redistributions of source code must retain the above copyright notice,
;    this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright
;    notice, this list of conditions and the following disclaimer in the
;    documentation and/or other materials provided with the distribution.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
; "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
; TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
; PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;
; The licence and distribution terms for any publically available
; version or derivative of this code cannot be changed. i.e. this code
; cannot simply be copied and put under another distribution licence
; (including the GNU Public Licence).

VERSION_MAJOR equ 1
VERSION_MINOR equ 30

;%include '../errors.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

out_of_memory:
	call	fatal_error
	.ascii	"out of memory"
	db 0
main_file_not_found:
	call	fatal_error
	.ascii	"source file not found"
	db 0
write_failed:
	call	fatal_error
	.ascii	"write failed"
	db 0
code_cannot_be_generated:
	call	fatal_error
	.ascii	"code cannot be generated"
	db 0
unexpected_end_of_file:
	call	fatal_error
	.ascii	"unexpected end of file"
	db 0
file_not_found:
	call	assembler_error
	.ascii	"file not found"
	db 0
error_reading_file:
	call	assembler_error
	.ascii	"error reading file"
	db 0
invalid_macro_arguments:
	call	assembler_error
	.ascii	"invalid macro arguments"
	db 0
unexpected_characters:
	call	assembler_error
	.ascii	"unexpected characters"
	db 0
invalid_argument:
	call	assembler_error
	.ascii	"invalid argument"
	db 0
illegal_instruction:
	call	assembler_error
	.ascii	"illegal instruction"
	db 0
unexpected_instruction:
	call	assembler_error
	.ascii	"unexpected instruction"
	db 0
invalid_operand:
	call	assembler_error
	.ascii	"invalid operand"
	db 0
invalid_operand_size:
	call	assembler_error
	.ascii	"invalid size of operand"
	db 0
operand_size_not_specified:
	call	assembler_error
	.ascii	"operand size not specified"
	db 0
operand_sizes_do_not_match:
	call	assembler_error
	.ascii	"operand sizes do not match"
	db 0
invalid_address_size:
	call	assembler_error
	.ascii	"invalid size of address value"
	db 0
address_sizes_do_not_agree:
	call	assembler_error
	.ascii	"address sizes do not agree"
	db 0
invalid_expression:
	call	assembler_error
	.ascii	"invalid expression"
	db 0
invalid_address:
	call	assembler_error
	.ascii	"invalid address"
	db 0
invalid_value:
	call	assembler_error
	.ascii	"invalid value"
	db 0
value_out_of_range:
	call	assembler_error
	.ascii	"value out of range"
	db 0
invalid_use_of_symbol:
	call	assembler_error
	.ascii	"invalid use of symbol"
	db 0
relative_jump_out_of_range:
	call	assembler_error
	.ascii	"relative jump out of range"
	db 0
extra_characters_on_line:
	call	assembler_error
	.ascii	"extra characters on line"
	db 0
name_too_long:
	call	assembler_error
	.ascii	"name too long"
	db 0
invalid_name:
	call	assembler_error
	.ascii	"invalid name"
	db 0
reserved_word_used_as_symbol:
	call	assembler_error
	.ascii	"reserved word used as symbol"
	db 0
symbol_already_defined:
	call	assembler_error
	.ascii	"symbol already defined"
	db 0
missing_end_quote:
	call	assembler_error
	.ascii	"missing end quote"
	db 0

;%include '../expressi.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

convert_expression:
	push	ebp
	mov	ebp,esp
	push	edi
	mov	edi,operators
	call	get_operator
	pop	edi
	or	al,al
	jz	expression_loop
	push	ebp
	cmp	al,0x80
	je	init_positive
	cmp	al,0x81
	je	init_negative
	jmp	invalid_expression
      init_positive:
	xor	al,al
	jmp	expression_number
      init_negative:
	mov	al,0xD1
	jmp	expression_number
      expression_loop:
	push	ebp
	push	edi
	mov	edi,single_operand_operators
	call	get_operator
	pop	edi
      expression_number:
	push	eax
	cmp	byte [esi],0
	je	invalid_expression
	call	convert_number
	pop	eax
	or	al,al
	jz	expression_operator
	stosb
      expression_operator:
	push	edi
	mov	edi,operators
	call	get_operator
	pop	edi
	pop	ebp
	or	al,al
	jz	expression_end
      operators_loop:
	cmp	esp,ebp
	je	push_operator
	mov	bl,al
	and	bl,0xF0
	mov	bh,byte [esp]
	and	bh,0xF0
	cmp	bl,bh
	ja	push_operator
	pop	bx
	mov	byte [edi],bl
	inc	edi
	jmp	operators_loop
      push_operator:
	push	ax
	jmp	expression_loop
      expression_end:
	cmp	esp,ebp
	je	expression_converted
	pop	ax
	stosb
	jmp	expression_end
      expression_converted:
	pop	ebp
	ret

convert_number:
	cmp	byte [esi],'(
	je	expression_value
	inc	edi
	call	get_number
	jc	symbol_value
	or	ebp,ebp
	jz	valid_number
	mov	byte [edi-1],0xF
	ret
      valid_number:
	cmp	dword [edi+4],0
	jne	qword_number
	cmp	word [edi+2],0
	jne	dword_number
	cmp	byte [edi+1],0
	jne	word_number
      byte_number:
	mov	byte [edi-1],1
	inc	edi
	ret
      qword_number:
	mov	byte [edi-1],8
	scasd
	scasd
	ret
      dword_number:
	mov	byte [edi-1],4
	scasd
	ret
      word_number:
	mov	byte [edi-1],2
	scasw
	ret
      expression_value:
	inc	esi
	call	convert_expression
	lodsb
	cmp	al,')
	jne	invalid_expression
	ret
      symbol_value:
	lodsb
	cmp	al,0x1A
	jne	invalid_value
	lodsb
	movzx	ecx,al
	push	ecx
	push	esi
	push	edi
	mov	edi,address_registers
	call	get_symbol
	jnc	register_value
	mov	edi,symbols
	call	get_symbol
	jnc	invalid_value
	pop	edi
	pop	esi
	pop	ecx
	call	get_label_id
	mov	byte [edi-1],0x11
	stosd
	ret
      register_value:
	pop	edi
	add	esp,8
	mov	byte [edi-1],0x10
	mov	al,ah
	stosb
	ret

get_number:
	xor	ebp,ebp
	lodsb
	cmp	al,0x22
	je	get_text_number
	cmp	al,0x1A
	jne	not_number
	lodsb
	movzx	ecx,al
	mov	dword [number_start],esi
	mov	al,[esi]
	sub	al,0x30
	jb	invalid_number
	cmp	al,9
	ja	invalid_number
	mov	eax,esi
	add	esi,ecx
	push	esi
	sub	esi,2
	mov	dword [edi],0
	mov	dword [edi+4],0
	inc	esi
	cmp	word [eax],'0+('x<<8)  ; Same multibyte character constant order in fasm and NASM.
	je	get_hex_number
	dec	esi
	cmp	byte [esi+1],'h
	je	get_hex_number
	cmp	byte [esi+1],'o
	je	get_oct_number
	cmp	byte [esi+1],'b
	je	get_bin_number
	cmp	byte [esi+1],'d
	je	get_dec_number
	inc	esi
	cmp	byte [eax],'0
	je	get_oct_number
      get_dec_number:
	xor	edx,edx
	mov	ebx,1
      get_dec_digit:
	cmp	esi,dword [number_start]
	jb	number_ok
	movzx	eax,byte [esi]
	sub	al,0x30
	jc	bad_number
	cmp	al,9
	ja	bad_number
	mov	ecx,eax
	jecxz	next_dec_digit
      convert_dec_digit:
	add	dword [edi],ebx
	adc	dword [edi+4],edx
	loop	convert_dec_digit
      next_dec_digit:
	dec	esi
	mov	ecx,edx
	mov	eax,10
	mul	ebx
	mov	ebx,eax
	imul	ecx,10
	jo	dec_out_of_range
	add	edx,ecx
	jnc	get_dec_digit
      dec_out_of_range:
	or	ebp,1
	jmp	get_dec_digit
      bad_number:
	pop	eax
      invalid_number:
	mov	esi,dword [number_start]
	dec	esi
      not_number:
	dec	esi
	stc
	ret
      get_bin_number:
	xor	bl,bl
      get_bin_digit:
	cmp	esi,dword [number_start]
	jb	number_ok
	movzx	eax,byte [esi]
	sub	al,0x30
	jc	bad_number
	cmp	al,1
	ja	bad_number
	xor	edx,edx
	mov	cl,bl
	dec	esi
	cmp	bl,64
	je	bin_out_of_range
	inc	bl
	cmp	cl,32
	jae	bin_digit_high
	shl	eax,cl
	or	dword [edi],eax
	jmp	get_bin_digit
      bin_digit_high:
	sub	cl,32
	shl	eax,cl
	or	dword [edi+4],eax
	jmp	get_bin_digit
      bin_out_of_range:
	or	ebp,1
	jmp	get_bin_digit
      get_hex_number:
	xor	bl,bl
      get_hex_digit:
	cmp	esi,dword [number_start]
	jb	number_ok
	movzx	eax,byte [esi]
	cmp	al,'x
	je	hex_number_ok
	sub	al,0x30
	jc	bad_number
	cmp	al,9
	jbe	hex_digit_ok
	sub	al,7
	cmp	al,15
	jbe	hex_digit_ok
	sub	al,0x20
	jc	bad_number
	cmp	al,15
	ja	bad_number
      hex_digit_ok:
	xor	edx,edx
	mov	cl,bl
	dec	esi
	cmp	bl,64
	je	hex_out_of_range
	add	bl,4
	cmp	cl,32
	jae	hex_digit_high
	shl	eax,cl
	or	dword [edi],eax
	jmp	get_hex_digit
      hex_digit_high:
	sub	cl,32
	shl	eax,cl
	or	dword [edi+4],eax
	jmp	get_hex_digit
      hex_out_of_range:
	or	ebp,1
	jmp	get_hex_digit
      get_oct_number:
	xor	bl,bl
      get_oct_digit:
	cmp	esi,dword [number_start]
	jb	number_ok
	movzx	eax,byte [esi]
	sub	al,0x30
	jc	bad_number
	cmp	al,7
	ja	bad_number
      oct_digit_ok:
	xor	edx,edx
	mov	cl,bl
	dec	esi
	cmp	bl,64
	jae	oct_out_of_range
	add	bl,3
	cmp	cl,32
	jae	oct_digit_high
	shl	eax,cl
	or	dword [edi],eax
	jmp	get_oct_digit
      oct_digit_high:
	sub	cl,32
	shl	eax,cl
	or	dword [edi+4],eax
	jmp	get_oct_digit
      oct_out_of_range:
	or	ebp,1
	jmp	get_oct_digit
      hex_number_ok:
	dec	esi
	cmp	esi,dword [number_start]
	jne	bad_number
      number_ok:
	pop	esi
      number_done:
	clc
	ret
      get_text_number:
	lodsd
	mov	edx,eax
	xor	bl,bl
	mov	dword [edi],0
	mov	dword [edi+4],0
      get_text_character:
	sub	edx,1
	jc	number_done
	movzx	eax,byte [esi]
	inc	esi
	mov	cl,bl
	cmp	bl,64
	je	text_out_of_range
	add	bl,8
	cmp	cl,32
	jae	text_character_high
	shl	eax,cl
	or	dword [edi],eax
	jmp	get_text_character
      text_character_high:
	sub	cl,32
	shl	eax,cl
	or	dword [edi+4],eax
	jmp	get_text_character
      text_out_of_range:
	or	ebp,1
	jmp	get_text_character

calculate_expression:
	lodsb
	or	al,al
	jz	get_string_value
	cmp	al,'.
	je	convert_fp
	cmp	al,1
	je	get_byte_number
	cmp	al,2
	je	get_word_number
	cmp	al,4
	je	get_dword_number
	cmp	al,8
	je	get_qword_number
	cmp	al,0xF
	je	value_out_of_range
	cmp	al,0x10
	je	get_register
	cmp	al,0x11
	je	get_label
	cmp	al,')
	je	expression_calculated
	cmp	al,']
	je	expression_calculated
	sub	edi,0x10
	mov	ebx,edi
	sub	ebx,0x10
	mov	dx,[ebx+8]
	or	dx,[edi+8]
	cmp	al,0xE0
	je	calculate_rva
	cmp	al,0xD0
	je	calculate_not
	cmp	al,0xD1
	je	calculate_neg
	cmp	al,0x80
	je	calculate_add
	cmp	al,0x81
	je	calculate_sub
	mov	ah,[ebx+12]
	or	ah,[edi+12]
	jnz	invalid_use_of_symbol
	cmp	al,0x90
	je	calculate_mul
	cmp	al,0x91
	je	calculate_div
	or	dx,dx
	jnz	invalid_expression
	cmp	al,0xA0
	je	calculate_mod
	cmp	al,0xB0
	je	calculate_and
	cmp	al,0xB1
	je	calculate_or
	cmp	al,0xB2
	je	calculate_xor
	cmp	al,0xC0
	je	calculate_shl
	cmp	al,0xC1
	je	calculate_shr
	jmp	invalid_expression
      expression_calculated:
	sub	edi,0x10
	ret
      get_byte_number:
	mov	word [edi+8],0
	mov	byte [edi+12],0
	xor	eax,eax
	lodsb
	stosd
	xor	al,al
	stosd
	scasd
	scasd
	jmp	calculate_expression
      get_word_number:
	mov	word [edi+8],0
	mov	byte [edi+12],0
	xor	eax,eax
	lodsw
	stosd
	xor	ax,ax
	stosd
	scasd
	scasd
	jmp	calculate_expression
      get_dword_number:
	mov	word [edi+8],0
	mov	byte [edi+12],0
	movsd
	xor	eax,eax
	stosd
	scasd
	scasd
	jmp	calculate_expression
      get_qword_number:
	mov	word [edi+8],0
	mov	byte [edi+12],0
	movsd
	movsd
	scasd
	scasd
	jmp	calculate_expression
      get_register:
	mov	byte [edi+9],0
	mov	byte [edi+12],0
	lodsb
	mov	[edi+8],al
	mov	byte [edi+10],1
	xor	eax,eax
	stosd
	stosd
	scasd
	scasd
	jmp	calculate_expression
      get_label:
	mov	word [edi+8],0
	mov	byte [edi+12],0
	lodsd
	or	eax,eax
	jz	current_offset_label
	cmp	eax,1
	je	counter_label
	mov	ebx,eax
	test	byte [ebx+8],1
	jz	label_undefined
	test	byte [ebx+8],4
	jz	label_defined
	mov	al,byte [current_pass]
	cmp	al,[ebx+9]
	jne	label_undefined
      label_defined:
	mov	al,[ebx+11]
	cmp	byte [next_pass_needed],0
	je	label_type_ok
	cmp	byte [current_pass],0
	jne	label_type_ok
	xor	al,al
      label_type_ok:
	mov	[edi+12],al
	mov	eax,[ebx+12]
	mov	[edi+8],eax
	mov	eax,[ebx]
	stosd
	mov	eax,[ebx+4]
	stosd
	scasd
	scasd
	mov	al,[ebx+10]
	or	al,al
	jz	calculate_expression
	cmp	byte [forced_size],2
	je	calculate_expression
	cmp	byte [forced_size],1
	jne	check_size
	cmp	byte [operand_size],0
	jne	calculate_expression
	mov	byte [operand_size],al
	jmp	calculate_expression
      check_size:
	xchg	byte [operand_size],al
	or	al,al
	jz	calculate_expression
	cmp	al,byte [operand_size]
	jne	operand_sizes_do_not_match
	jmp	calculate_expression
      current_offset_label:
	cmp	byte [reloc_labels],0
	je	get_current_offset
	mov	byte [edi+12],2
      get_current_offset:
	mov	eax,dword [current_offset]
	sub	eax,dword [org_start]
	cdq
	stosd
	mov	eax,edx
	stosd
	mov	eax,dword [org_sib]
	stosd
	scasd
	jmp	calculate_expression
      counter_label:
	mov	eax,dword [counter]
	stosd
	xor	eax,eax
	stosd
	scasd
	scasd
	jmp	calculate_expression
      label_undefined:
	cmp	byte [current_pass],0
	jne	invalid_value
	or	byte [next_pass_needed],-1
	mov	byte [edi+12],0
	xor	eax,eax
	stosd
	stosd
	scasd
	scasd
	jmp	calculate_expression
      calculate_add:
	cmp	byte [next_pass_needed],0
	jne	add_values
	cmp	byte [edi+12],0
	je	add_values
	cmp	byte [ebx+12],0
	jne	invalid_use_of_symbol
      add_values:
	mov	al,[edi+12]
	or	[ebx+12],al
	mov	eax,[edi]
	add	[ebx],eax
	mov	eax,[edi+4]
	adc	[ebx+4],eax
	or	dx,dx
	jz	calculate_expression
	push	esi
	mov	esi,ebx
	lea	ebx,[edi+10]
	mov	cl,[edi+8]
	call	add_register
	lea	ebx,[edi+11]
	mov	cl,[edi+9]
	call	add_register
	pop	esi
	jmp	calculate_expression
      add_register:
	or	cl,cl
	jz	add_register_done
      add_register_start:
	cmp	[esi+8],cl
	jne	add_in_second_slot
	mov	al,[ebx]
	add	[esi+10],al
	jnz	add_register_done
	mov	byte [esi+8],0
	ret
      add_in_second_slot:
	cmp	[esi+9],cl
	jne	create_in_first_slot
	mov	al,[ebx]
	add	[esi+11],al
	jnz	add_register_done
	mov	byte [esi+9],0
	ret
      create_in_first_slot:
	cmp	byte [esi+8],0
	jne	create_in_second_slot
	mov	[esi+8],cl
	mov	al,[ebx]
	mov	[esi+10],al
	ret
      create_in_second_slot:
	cmp	byte [esi+9],0
	jne	invalid_expression
	mov	[esi+9],cl
	mov	al,[ebx]
	mov	[esi+11],al
      add_register_done:
	ret
      calculate_sub:
	xor	ah,ah
	cmp	byte [next_pass_needed],0
	jne	sub_values
	mov	ah,[ebx+12]
	mov	al,[edi+12]
	or	al,al
	jz	sub_values
	cmp	al,ah
	jne	invalid_use_of_symbol
	xor	ah,ah
      sub_values:
	mov	byte [ebx+12],ah
	mov	eax,[edi]
	sub	[ebx],eax
	mov	eax,[edi+4]
	sbb	[ebx+4],eax
	or	dx,dx
	jz	calculate_expression
	push	esi
	mov	esi,ebx
	lea	ebx,[edi+10]
	mov	cl,[edi+8]
	call	sub_register
	lea	ebx,[edi+11]
	mov	cl,[edi+9]
	call	sub_register
	pop	esi
	jmp	calculate_expression
      sub_register:
	or	cl,cl
	jz	add_register_done
	neg	byte [ebx]
	jmp	add_register_start
      calculate_mul:
	or	dx,dx
	jz	mul_start
	cmp	word [ebx+8],0
	jne	mul_start
	mov	eax,[ebx]
	xchg	eax,[edi]
	mov	[ebx],eax
	mov	eax,[ebx+4]
	xchg	eax,[edi+4]
	mov	[ebx+4],eax
	mov	eax,[ebx+8]
	xchg	eax,[edi+8]
	mov	[ebx+8],eax
	mov	eax,[ebx+12]
	xchg	eax,[edi+12]
	mov	[ebx+12],eax
      mul_start:
	push	esi
	push	dx
	mov	esi,ebx
	xor	bl,bl
	test	dword [esi+4],1 << 31
	jz	mul_first_sign_ok
	not	dword [esi]
	not	dword [esi+4]
	add	dword [esi],1
	adc	dword [esi+4],0
	not	bl
      mul_first_sign_ok:
	test	dword [edi+4],1 << 31
	jz	mul_second_sign_ok
	not	dword [edi]
	not	dword [edi+4]
	add	dword [edi],1
	adc	dword [edi+4],0
	not	bl
      mul_second_sign_ok:
	cmp	dword [esi+4],0
	jz	mul_numbers
	cmp	dword [edi+4],0
	jnz	value_out_of_range
      mul_numbers:
	mov	eax,[esi+4]
	mul	dword [edi]
	or	edx,edx
	jnz	value_out_of_range
	mov	ecx,eax
	mov	eax,[esi]
	mul	dword [edi+4]
	or	edx,edx
	jnz	value_out_of_range
	add	ecx,eax
	jc	value_out_of_range
	mov	eax,[esi]
	mul	dword [edi]
	add	edx,ecx
	jc	value_out_of_range
	mov	[esi],eax
	mov	[esi+4],edx
	or	bl,bl
	jz	mul_ok
	not	dword [esi]
	not	dword [esi+4]
	add	dword [esi],1
	adc	dword [esi+4],0
      mul_ok:
	pop	dx
	or	dx,dx
	jz	mul_calculated
	cmp	word [edi+8],0
	jne	invalid_value
	cmp	byte [esi+8],0
	je	mul_first_register_ok
	mov	al,[edi]
	cbw
	cwde
	cdq
	cmp	edx,[edi+4]
	jne	value_out_of_range
	cmp	eax,[edi]
	jne	value_out_of_range
	imul	byte [esi+10]
	mov	dl,ah
	cbw
	cmp	ah,dl
	jne	value_out_of_range
	mov	[esi+10],al
      mul_first_register_ok:
	cmp	byte [esi+9],0
	je	mul_calculated
	mov	al,[edi]
	cbw
	cwde
	cdq
	cmp	edx,[edi+4]
	jne	value_out_of_range
	cmp	eax,[edi]
	jne	value_out_of_range
	imul	byte [esi+11]
	mov	dl,ah
	cbw
	cmp	ah,dl
	jne	value_out_of_range
	mov	[esi+11],al
      mul_calculated:
	pop	esi
	jmp	calculate_expression
      calculate_div:
	push	esi
	push	dx
	mov	esi,ebx
	call	div_64
	pop	dx
	or	dx,dx
	jz	div_calculated
	cmp	byte [esi+8],0
	je	div_first_register_ok
	mov	al,[edi]
	cbw
	cwde
	cdq
	cmp	edx,[edi+4]
	jne	value_out_of_range
	cmp	eax,[edi]
	jne	value_out_of_range
	or	al,al
	jz	value_out_of_range
	mov	al,[esi+10]
	cbw
	idiv	byte [edi]
	mov	[esi+10],al
      div_first_register_ok:
	cmp	byte [esi+9],0
	je	div_calculated
	mov	al,[edi]
	cbw
	cwde
	cdq
	cmp	edx,[edi+4]
	jne	value_out_of_range
	cmp	eax,[edi]
	jne	value_out_of_range
	or	al,al
	jz	value_out_of_range
	mov	al,[esi+11]
	cbw
	idiv	byte [edi]
	mov	[esi+11],al
      div_calculated:
	pop	esi
	jmp	calculate_expression
      calculate_mod:
	push	esi
	mov	esi,ebx
	call	div_64
	mov	[esi],eax
	mov	[esi+4],edx
	pop	esi
	jmp	calculate_expression
      calculate_and:
	mov	eax,[edi]
	and	[ebx],eax
	mov	eax,[edi+4]
	and	[ebx+4],eax
	jmp	calculate_expression
      calculate_or:
	mov	eax,[edi]
	or	[ebx],eax
	mov	eax,[edi+4]
	or	[ebx+4],eax
	jmp	calculate_expression
      calculate_xor:
	cmp	byte [value_size],1
	je	xor_byte
	cmp	byte [value_size],2
	je	xor_word
	cmp	byte [value_size],4
	je	xor_dword
	cmp	byte [value_size],6
	je	xor_pword
      xor_qword:
	mov	eax,[edi]
	xor	[ebx],eax
	mov	eax,[edi+4]
	xor	[ebx+4],eax
	jmp	calculate_expression
      xor_byte:
	cmp	dword [edi+4],0
	jne	xor_qword
	cmp	word [edi+2],0
	jne	xor_qword
	cmp	byte [edi+1],0
	jne	xor_qword
	mov	al,[edi]
	xor	[ebx],al
	jmp	calculate_expression
      xor_word:
	cmp	dword [edi+4],0
	jne	xor_qword
	cmp	word [edi+2],0
	jne	xor_qword
	mov	ax,[edi]
	xor	[ebx],ax
	jmp	calculate_expression
      xor_dword:
	cmp	dword [edi+4],0
	jne	xor_qword
	mov	eax,[edi]
	xor	[ebx],eax
	jmp	calculate_expression
      xor_pword:
	cmp	word [edi+6],0
	jne	xor_qword
	mov	eax,[edi]
	xor	[ebx],eax
	mov	ax,[edi+4]
	xor	[ebx+4],ax
	jmp	calculate_expression
      calculate_shl:
	mov	eax,dword [edi+4]
	test	eax,1 << 31
	jnz	shl_negative
	or	eax,eax
	jnz	zero_value
	mov	ecx,[edi]
	cmp	ecx,64
	jae	zero_value
	cmp	ecx,32
	jae	shl_high
	mov	edx,[ebx+4]
	mov	eax,[ebx]
	shld	edx,eax,cl
	shl	eax,cl
	mov	[ebx],eax
	mov	[ebx+4],edx
	jmp	calculate_expression
      shl_high:
	sub	cl,32
	mov	eax,[ebx]
	shl	eax,cl
	mov	[ebx+4],eax
	mov	dword [ebx],0
	jmp	calculate_expression
      shl_negative:
	not	dword [edi]
	not	dword [edi+4]
	add	dword [edi],1
	adc	dword [edi+4],0
      calculate_shr:
	mov	eax,dword [edi+4]
	test	eax,1 << 31
	jnz	shr_negative
	or	eax,eax
	jnz	zero_value
	mov	ecx,[edi]
	cmp	ecx,64
	jae	zero_value
	cmp	ecx,32
	jae	shr_high
	mov	edx,[ebx+4]
	mov	eax,[ebx]
	shrd	eax,edx,cl
	shr	edx,cl
	mov	[ebx],eax
	mov	[ebx+4],edx
	jmp	calculate_expression
      shr_high:
	sub	cl,32
	mov	eax,[ebx+4]
	shr	eax,cl
	mov	[ebx],eax
	mov	dword [ebx+4],0
	jmp	calculate_expression
      shr_negative:
	not	dword [edi]
	not	dword [edi+4]
	add	dword [edi],1
	adc	dword [edi+4],0
	jmp	calculate_shl
      zero_value:
	mov	dword [ebx],0
	mov	dword [ebx+4],0
	jmp	calculate_expression
      calculate_not:
	cmp	word [edi+8],0
	jne	invalid_expression
	cmp	byte [edi+12],0
	jne	invalid_use_of_symbol
	cmp	byte [value_size],1
	je	not_byte
	cmp	byte [value_size],2
	je	not_word
	cmp	byte [value_size],4
	je	not_dword
	cmp	byte [value_size],6
	je	not_pword
      not_qword:
	not	dword [edi]
	not	dword [edi+4]
	add	edi,0x10
	jmp	calculate_expression
      not_byte:
	cmp	dword [edi+4],0
	jne	not_qword
	cmp	word [edi+2],0
	jne	not_qword
	cmp	byte [edi+1],0
	jne	not_qword
	not	byte [edi]
	add	edi,0x10
	jmp	calculate_expression
      not_word:
	cmp	dword [edi+4],0
	jne	not_qword
	cmp	word [edi+2],0
	jne	not_qword
	not	word [edi]
	add	edi,0x10
	jmp	calculate_expression
      not_dword:
	cmp	dword [edi+4],0
	jne	not_qword
	not	dword [edi]
	add	edi,0x10
	jmp	calculate_expression
      not_pword:
	cmp	word [edi+6],0
	jne	not_qword
	not	dword [edi]
	not	word [edi+4]
	add	edi,0x10
	jmp	calculate_expression
      calculate_neg:
	cmp	word [edi+8],0
	jne	invalid_expression
	cmp	byte [edi+12],0
	jne	invalid_use_of_symbol
	mov	eax,[edi]
	mov	edx,[edi+4]
	mov	dword [edi],0
	mov	dword [edi+4],0
	sub	[edi],eax
	sbb	[edi+4],edx
	add	edi,0x10
	jmp	calculate_expression
      calculate_rva:
	cmp	word [edi+8],0
	jne	invalid_expression
	mov	al,[edi+12]
	cmp	al,2
	je	rva_ok
	or	al,al
	jnz	invalid_use_of_symbol
	cmp	byte [next_pass_needed],0
	je	invalid_use_of_symbol
      rva_ok:
	mov	byte [edi+12],0
	mov	eax,dword [header_data]
	mov	eax,[eax+0x34]
	sub	[edi],eax
	sbb	dword [edi+4],0
	add	edi,0x10
	jmp	calculate_expression
      div_64:
	xor	bl,bl
	cmp	dword [edi],0
	jne	divider_ok
	cmp	dword [edi+4],0
	jne	divider_ok
	cmp	byte [next_pass_needed],0
	je	value_out_of_range
	jmp	div_done
      divider_ok:
	test	dword [esi+4],1 << 31
	jz	div_first_sign_ok
	not	dword [esi]
	not	dword [esi+4]
	add	dword [esi],1
	adc	dword [esi+4],0
	not	bl
      div_first_sign_ok:
	test	dword [edi+4],1 << 31
	jz	div_second_sign_ok
	not	dword [edi]
	not	dword [edi+4]
	add	dword [edi],1
	adc	dword [edi+4],0
	not	bl
      div_second_sign_ok:
	cmp	dword [edi+4],0
	jne	div_high
	mov	ecx,[edi]
	mov	eax,[esi+4]
	xor	edx,edx
	div	ecx
	mov	[esi+4],eax
	mov	eax,[esi]
	div	ecx
	mov	[esi],eax
	mov	eax,edx
	xor	edx,edx
	jmp	div_done
      div_high:
	mov	eax,[esi+4]
	xor	edx,edx
	div	dword [edi+4]
	mov	ebx,[esi]
	mov	[esi],eax
	mov	dword [esi+4],0
	mov	ecx,edx
	mul	dword [edi]
      div_high_loop:
	cmp	ecx,edx
	ja	div_high_done
	jb	div_high_change
	cmp	ebx,eax
	jae	div_high_done
      div_high_change:
	dec	dword [esi]
	sub	eax,[edi]
	sbb	edx,[edi+4]
	jnc	div_high_loop
      div_high_done:
	sub	ebx,eax
	sbb	ecx,edx
	mov	edx,ecx
	mov	eax,ebx
	ret
      div_done:
	or	bl,bl
	jz	div_ok
	not	dword [esi]
	not	dword [esi+4]
	add	dword [esi],1
	adc	dword [esi+4],0
      div_ok:
	ret
      convert_fp:
	mov	word [edi+8],0
	mov	byte [edi+12],0
	mov	al,byte [value_size]
	cmp	al,4
	je	convert_fp_dword
	cmp	al,8
	je	convert_fp_qword
	jmp	invalid_value
      convert_fp_dword:
	xor	eax,eax
	cmp	word [esi+8],0x8000
	je	fp_dword_store
	mov	bx,[esi+8]
	mov	eax,[esi+4]
	shl	eax,1
	shr	eax,9
	jnc	fp_dword_ok
	inc	eax
	test	eax,1 << 23
	jz	fp_dword_ok
	and	eax,(1 << 23) - 1
	inc	bx
	shr	eax,1
      fp_dword_ok:
	add	bx,0x7F
	cmp	bx,0x100
	jae	value_out_of_range
	shl	ebx,23
	or	eax,ebx
	mov	bl,[esi+11]
	shl	ebx,31
	or	eax,ebx
      fp_dword_store:
	mov	[edi],eax
	xor	eax,eax
	mov	[edi+4],eax
	add	esi,12
	ret
      convert_fp_qword:
	xor	eax,eax
	xor	edx,edx
	cmp	word [esi+8],0x8000
	je	fp_qword_store
	mov	bx,[esi+8]
	mov	eax,[esi]
	mov	edx,[esi+4]
	shl	eax,1
	rcl	edx,1
	mov	ecx,edx
	shr	edx,12
	shrd	eax,ecx,12
	jnc	fp_qword_ok
	add	eax,1
	adc	edx,0
	test	edx,1 << 20
	jz	fp_qword_ok
	and	edx,(1 << 20) - 1
	inc	bx
	shr	edx,1
	rcr	eax,1
      fp_qword_ok:
	add	bx,0x3FF
	cmp	bx,0x800
	jae	value_out_of_range
	shl	ebx,20
	or	edx,ebx
	mov	bl,[esi+11]
	shl	ebx,31
	or	edx,ebx
      fp_qword_store:
	mov	[edi],eax
	mov	[edi+4],edx
	add	esi,12
	ret
      get_string_value:
	lodsd
	mov	ecx,eax
	cmp	ecx,8
	ja	value_out_of_range
	mov	edx,edi
	xor	eax,eax
	stosd
	stosd
	mov	edi,edx
	rep
	movsb
	mov	edi,edx
	inc	esi
	mov	word [edi+8],0
	mov	byte [edi+12],0
	ret

get_byte_value:
	mov	byte [value_size],1
	mov	byte [forced_size],2
	mov	dword [current_offset],edi
	call	calculate_expression
	cmp	word [edi+8],0
	jne	invalid_value
	cmp	byte [edi+12],0
	jne	invalid_use_of_symbol
	mov	eax,[edi]
	cmp	dword [edi+4],0
	je	byte_positive
	cmp	dword [edi+4],-1
	jne	range_exceeded
	cmp	eax,-0x80
	jb	range_exceeded
	ret
      byte_positive:
	cmp	eax,0x100
	jae	range_exceeded
      return_value:
	ret
      range_exceeded:
	cmp	dword [error_line],0
	jne	return_value
	mov	eax,dword [current_line]
	mov	dword [error_line],eax
	mov	dword [error],value_out_of_range
	ret
get_word_value:
	mov	byte [value_size],2
	mov	byte [forced_size],2
	mov	dword [current_offset],edi
	call	calculate_expression
	cmp	word [edi+8],0
	jne	invalid_value
	mov	al,[edi+12]
	cmp	al,2
	je	invalid_use_of_symbol
	mov	byte [value_type],al
      check_word_value:
	mov	eax,[edi]
	cmp	dword [edi+4],0
	je	word_positive
	cmp	dword [edi+4],-1
	jne	range_exceeded
	cmp	eax,-0x8000
	jb	range_exceeded
	ret
      word_positive:
	cmp	eax,0x10000
	jae	range_exceeded
	ret
get_dword_value:
	mov	byte [value_size],4
	mov	byte [forced_size],2
	mov	dword [current_offset],edi
	call	calculate_expression
	cmp	word [edi+8],0
	jne	invalid_value
	mov	al,[edi+12]
	mov	byte [value_type],al
      check_dword_value:
	mov	eax,[edi]
	cmp	dword [edi+4],0
	je	dword_positive
	cmp	dword [edi+4],-1
	jne	range_exceeded
	test	eax,1 << 31
	jz	range_exceeded
      dword_positive:
	ret
get_pword_value:
	mov	byte [value_size],6
	mov	byte [forced_size],2
	mov	dword [current_offset],edi
	call	calculate_expression
	cmp	word [edi+8],0
	jne	invalid_value
	mov	al,[edi+12]
	mov	byte [value_type],al
	mov	eax,[edi]
	mov	edx,[edi+4]
	cmp	edx,0x10000
	jge	range_exceeded
	cmp	edx,-0x8000
	jl	range_exceeded
	ret
get_qword_value:
	mov	byte [value_size],8
	mov	byte [forced_size],2
	mov	dword [current_offset],edi
	call	calculate_expression
	cmp	word [edi+8],0
	jne	invalid_value
	mov	al,[edi+12]
	mov	byte [value_type],al
	mov	eax,[edi]
	mov	edx,[edi+4]
	ret
get_value:
	mov	byte [operand_size],0
	mov	byte [forced_size],0
	lodsb
	call	get_size_operator
	cmp	al,'(
	jne	invalid_value
	mov	al,byte [operand_size]
	cmp	al,1
	je	value_byte
	cmp	al,2
	je	value_word
	cmp	al,4
	je	value_dword
	cmp	al,6
	je	value_pword
	cmp	al,8
	je	value_qword
	or	al,al
	jnz	invalid_value
      value_qword:
	call	get_qword_value
	ret
      value_pword:
	call	get_pword_value
	movzx	edx,dx
	ret
      value_dword:
	call	get_dword_value
	xor	edx,edx
	ret
      value_word:
	call	get_word_value
	xor	edx,edx
	movzx	eax,ax
	ret
      value_byte:
	call	get_byte_value
	xor	edx,edx
	movzx	eax,al
	ret

get_address:
	mov	byte [segment_register],0
	mov	byte [address_size],0
	mov	byte [value_size],4
	push	dword address_ok
	mov	al,[esi]
	and	al,%11110000
	cmp	al,0x60
	jne	get_size_prefix
	lodsb
	sub	al,0x60
	mov	byte [segment_register],al
	mov	al,[esi]
	and	al,%11110000
      get_size_prefix:
	cmp	al,0x70
	jne	calculate_address
	lodsb
	sub	al,0x70
	cmp	al,4
	ja	invalid_address_size
	mov	byte [address_size],al
	mov	byte [value_size],al
	jmp	calculate_address
get_address_value:
	mov	byte [address_size],0
	mov	byte [value_size],4
	push	dword address_ok
      calculate_address:
	mov	dword [current_offset],edi
	call	calculate_expression
	mov	al,[edi+12]
	mov	byte [value_type],al
	cmp	al,1
	je	invalid_use_of_symbol
	or	al,al
	jz	address_symbol_ok
	mov	al,0x84
	xchg	byte [address_size],al
	or	al,al
	jz	address_symbol_ok
	cmp	al,4
	jne	address_sizes_do_not_agree
      address_symbol_ok:
	xor	bx,bx
	xor	cl,cl
	mov	ch,byte [address_size]
	cmp	word [edi+8],0
	je	check_dword_value
	mov	al,[edi+8]
	mov	dl,[edi+10]
	call	get_address_register
	mov	al,[edi+9]
	mov	dl,[edi+11]
	call	get_address_register
	mov	ax,bx
	shr	ah,4
	shr	al,4
	or	bh,bh
	jz	check_address_registers
	or	bl,bl
	jz	check_address_registers
	cmp	al,ah
	jne	invalid_address
      check_address_registers:
	or	al,ah
	cmp	al,2
	je	address_16bit
	cmp	al,4
	jne	invalid_address
	or	bh,bh
	jnz	check_index_scale
	cmp	cl,2
	je	special_index_scale
	cmp	cl,3
	je	special_index_scale
	cmp	cl,5
	je	special_index_scale
	cmp	cl,9
	je	special_index_scale
      check_index_scale:
	or	cl,cl
	jz	address_registers_ok
	cmp	cl,1
	je	address_registers_ok
	cmp	cl,2
	je	address_registers_ok
	cmp	cl,4
	je	address_registers_ok
	cmp	cl,8
	je	address_registers_ok
	jmp	invalid_address
      special_index_scale:
	mov	bh,bl
	dec	cl
      address_registers_ok:
	jmp	check_dword_value
      address_16bit:
	or	cl,cl
	jz	check_word_value
	cmp	cl,1
	je	check_word_value
	jmp	invalid_address
      get_address_register:
	or	al,al
	jz	address_register_ok
	cmp	dl,1
	jne	scaled_register
	or	bh,bh
	jnz	scaled_register
	mov	bh,al
      address_register_ok:
	ret
      scaled_register:
	or	bl,bl
	jnz	invalid_address
	mov	bl,al
	mov	cl,dl
	jmp	address_register_ok
      address_ok:
	mov	edx,eax
	ret

calculate_logical_expression:
	call	get_logical_value
      logical_loop:
	push	ax
	lodsb
	cmp	al,'|
	je	logical_or
	cmp	al,'&
	je	logical_and
	dec	esi
	pop	ax
	ret
      logical_or:
	call	get_logical_value
	pop	bx
	or	al,bl
	jmp	logical_loop
      logical_and:
	call	get_logical_value
	pop	bx
	and	al,bl
	jmp	logical_loop

get_logical_value:
	xor	al,al
	cmp	byte [esi],'~
	jne	negation_ok
	inc	esi
	or	al,-1
      negation_ok:
	push	ax
	cmp	byte [esi],'{
	je	logical_expression
	push	esi
	cmp	byte [esi],0x11
	jne	check_for_values
	add	esi,2
      check_for_values:
	xor	bl,bl
	cmp	byte [esi],'(
	jne	find_eq_symbol
	call	skip_symbol
	lodsb
	cmp	al,'=
	je	compare_values
	cmp	al,'>
	je	compare_values
	cmp	al,'<
	je	compare_values
	cmp	al,0xf2
	je	compare_values
	cmp	al,0xf3
	je	compare_values
	cmp	al,0xf6
	je	compare_values
	dec	esi
      find_eq_symbol:
	cmp	byte [esi],0x81
	je	compare_symbols
	cmp	byte [esi],0x83
	je	scan_symbols_list
	call	check_character
	jc	logical_number
	cmp	al,',
	jne	next_eq_symbol
	mov	bl,1
      next_eq_symbol:
	call	skip_symbol
	jmp	find_eq_symbol
      compare_symbols:
	inc	esi
	pop	ebx
	mov	edx,esi
	push	edi
	mov	edi,ebx
	mov	ecx,esi
	dec	ecx
	sub	ecx,edi
	repe
	cmpsb
	pop	edi
	je	symbols_equal
	mov	esi,edx
      symbols_different:
	call	check_character
	jc	return_false
	call	skip_symbol
	jmp	symbols_different
      symbols_equal:
	call	check_character
	jc	return_true
	jmp	symbols_different
      scan_symbols_list:
	or	bl,bl
	jnz	invalid_expression
	xor	bp,bp
	inc	esi
	lodsb
	cmp	al,'<
	jne	invalid_expression
	pop	ebx
	mov	ecx,esi
	sub	ecx,2
	sub	ecx,ebx
      compare_in_list:
	mov	edx,esi
	push	ecx
	push	edi
	mov	edi,ebx
	repe
	cmpsb
	pop	edi
	pop	ecx
	jne	not_equal_in_list
	cmp	byte [esi],',
	je	skip_rest_of_list
	cmp	byte [esi],'>
	jne	not_equal_in_list
      skip_rest_of_list:
	call	check_character
	jc	invalid_expression
	cmp	al,'>
	je	list_return_true
	call	skip_symbol
	jmp	skip_rest_of_list
      list_return_true:
	inc	esi
	jmp	return_true
      not_equal_in_list:
	mov	esi,edx
      skip_list_item:
	call	check_character
	jc	invalid_expression
	cmp	al,'>
	je	list_return_false
	cmp	al,',
	je	next_in_list
	call	skip_symbol
	jmp	skip_list_item
      next_in_list:
	inc	esi
	jmp	compare_in_list
      list_return_false:
	inc	esi
	jmp	return_false
      check_character:
	mov	al,[esi]
	or	al,al
	jz	stop
	cmp	al,0xF
	je	stop
	cmp	al,'}
	je	stop
	cmp	al,'|
	je	stop
	cmp	al,'&
	je	stop
	clc
	ret
      stop:
	stc
	ret
      compare_values:
	pop	esi
	call	get_value
	mov	bl,byte [value_type]
	push	eax
	push	edx
	push	bx
	lodsb
	mov	byte [compare_type],al
	call	get_value
	pop	bx
	cmp	byte [next_pass_needed],0
	jne	values_ok
	cmp	bl,byte [value_type]
	jne	invalid_use_of_symbol
      values_ok:
	pop	ecx
	pop	ebx
	cmp	byte [compare_type],'=
	je	check_equal
	cmp	byte [compare_type],'>
	je	check_greater
	cmp	byte [compare_type],'<
	je	check_less
	cmp	byte [compare_type],0xf2
	je	check_not_less
	cmp	byte [compare_type],0xf3
	je	check_not_greater
	cmp	byte [compare_type],0xf6
	je	check_not_equal
	jmp	invalid_expression
      check_equal:
	cmp	eax,ebx
	jne	return_false
	cmp	edx,ecx
	jne	return_false
	jmp	return_true
      check_greater:
	cmp	edx,ecx
	jl	return_true
	jg	return_false
	cmp	eax,ebx
	jb	return_true
	jae	return_false
      check_less:
	cmp	edx,ecx
	jl	return_false
	jg	return_true
	cmp	eax,ebx
	jbe	return_false
	ja	return_true
      check_not_less:
	cmp	edx,ecx
	jl	return_true
	jg	return_false
	cmp	eax,ebx
	jbe	return_true
	ja	return_false
      check_not_greater:
	cmp	edx,ecx
	jl	return_false
	jg	return_true
	cmp	eax,ebx
	jb	return_false
	jae	return_true
      check_not_equal:
	cmp	eax,ebx
	jne	return_true
	cmp	edx,ecx
	jne	return_true
	jmp	return_false
      logical_number:
	pop	esi
	call	get_value
	cmp	byte [value_type],0
	jne	invalid_expression
	or	eax,edx
	jnz	return_true
      return_false:
	xor	al,al
	jmp	logical_value_ok
      return_true:
	or	al,-1
	jmp	logical_value_ok
      logical_expression:
	inc	esi
	call	calculate_logical_expression
	push	ax
	lodsb
	cmp	al,'}
	jne	invalid_expression
	pop	ax
      logical_value_ok:
	pop	bx
	xor	al,bl
	ret

;%include '../preproce.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

preprocessor:
	mov	eax,dword [memory_start]
	mov	dword [source_start],eax
	push	dword [additional_memory]
	mov	eax,dword [additional_memory]
	mov	dword [macros_list],eax
	mov	eax,dword [additional_memory_end]
	mov	dword [labels_list],eax
	mov	dword [display_buffer],0
	mov	byte [macro_status],0
	mov	edx,dword [input_file]
	mov	edi,dword [memory_start]
	call	preprocess_file
	jc	main_file_not_found
	cmp	byte [macro_status],0
	jne	unexpected_end_of_file
	pop	dword [additional_memory]
	mov	dword [code_start],edi
	ret

preprocess_file:
	push	dword [memory_end]
	push	edx
	call	open
	jc	no_source_file
	mov	al,2
	xor	edx,edx
	call	lseek
	push	eax
	xor	al,al
	xor	edx,edx
	call	lseek
	pop	ecx
	mov	edx,dword [memory_end]
	dec	edx
	mov	byte [edx],0x1A
	sub	edx,ecx
	jc	out_of_memory
	mov	esi,edx
	cmp	edx,edi
	jbe	out_of_memory
	mov	dword [memory_end],edx
	call	read
	call	close
	pop	edx
	xor	ecx,ecx
	mov	ebx,esi
      preprocess_source:
	inc	ecx
	mov	dword [current_line],edi
	mov	eax,edx
	stosd
	mov	eax,ecx
	stosd
	mov	eax,esi
	sub	eax,ebx
	stosd
	push	ebx
	push	edx
	call	convert_line
	call	preprocess_line
	pop	edx
	pop	ebx
      next_line:
	cmp	byte [esi-1],0x1A
	jne	preprocess_source
      file_end:
	pop	dword [memory_end]
	clc
	ret
      no_source_file:
	pop	eax
	pop	eax
	stc
	ret

convert_line:
	push	ecx
	cmp	byte [macro_status],0
	jle	convert_line_data
	mov	ax,0x3B
	stosw
      convert_line_data:
	cmp	edi,dword [memory_end]
	jae	out_of_memory
	lodsb
	cmp	al,0x20
	je	convert_line_data
	cmp	al,9
	je	convert_line_data
	dec	esi
	lodsb
	mov	ah,al
	mov	ebx,characters
	xlatb
	or	al,al
	jz	convert_separator
	cmp	ah,0x27
	je	convert_string
	cmp	ah,0x22
	je	convert_string
	mov	byte [edi],0x1A
	scasw
	stosb
	mov	ebx,characters
	xor	ecx,ecx
      convert_symbol:
	lodsb
	xlatb
	stosb
	or	al,al
	loopnz convert_symbol
	neg	ecx
	cmp	ecx,255
	ja	name_too_long
	dec	edi
	mov	ebx,edi
	sub	ebx,ecx
	mov	byte [ebx-1],cl
	mov	ah,[esi-1]
      convert_separator:
	xchg	al,ah
	cmp	al,0x20
	jb	control_character
	je	convert_line_data
      symbol_character:
	cmp	al,0x3B
	je	ignore_comment
	cmp	al,0x5C
	je	concate_lines
	stosb
	jmp	convert_line_data
      control_character:
	cmp	al,0x1A
	je	line_end
	cmp	al,0xD
	je	cr_character
	cmp	al,0xA
	je	lf_character
	cmp	al,9
	je	convert_line_data
	or	al,al
	jnz	symbol_character
	jmp	line_end
      lf_character:
	lodsb
	cmp	al,0xD
	je	line_end
	dec	esi
	jmp	line_end
      cr_character:
	lodsb
	cmp	al,0xA
	je	line_end
	dec	esi
	jmp	line_end
      convert_string:
	mov	al,0x22
	stosb
	scasd
	mov	ebx,edi
      copy_string:
	lodsb
	stosb
	cmp	al,0xA
	je	missing_end_quote
	cmp	al,0xD
	je	missing_end_quote
	or	al,al
	jz	missing_end_quote
	cmp	al,0x1A
	je	missing_end_quote
	cmp	al,ah
	jne	copy_string
	lodsb
	cmp	al,ah
	je	copy_string
	dec	esi
	dec	edi
	mov	eax,edi
	sub	eax,ebx
	mov	[ebx-4],eax
	jmp	convert_line_data
      concate_lines:
	lodsb
	cmp	al,0x20
	je	concate_lines
	cmp	al,9
	je	concate_lines
	cmp	al,0x1A
	je	unexpected_end_of_file
	cmp	al,0xA
	je	concate_lf
	cmp	al,0xD
	je	concate_cr
	cmp	al,0x3B
	jne	extra_characters_on_line
      find_concated_line:
	lodsb
	cmp	al,0xA
	je	concate_lf
	cmp	al,0xD
	je	concate_cr
	or	al,al
	jz	concate_ok
	cmp	al,0x1A
	jne	find_concated_line
	jmp	unexpected_end_of_file
      concate_lf:
	lodsb
	cmp	al,0xD
	je	concate_ok
	dec	esi
	jmp	concate_ok
      concate_cr:
	lodsb
	cmp	al,0xA
	je	concate_ok
	dec	esi
      concate_ok:
	inc	dword [esp]
	jmp	convert_line_data
      ignore_comment:
	lodsb
	cmp	al,0xA
	je	lf_character
	cmp	al,0xD
	je	cr_character
	or	al,al
	jz	line_end
	cmp	al,0x1A
	jne	ignore_comment
      line_end:
	xor	al,al
	stosb
	pop	ecx
	ret

preprocess_line:
	push	dword [struc_name]
	push	ecx
	push	esi
	mov	esi,dword [current_line]
	add	esi,12
	mov	al,byte [macro_status]
	dec	al
	jz	find_macro_block
	dec	al
	jz	skip_macro_block
      preprocess_instruction:
	lodsb
	cmp	al,':
	je	preprocess_instruction
	movzx	ecx,byte [esi]
	inc	esi
	cmp	al,0x1A
	jne	not_preprocessor_symbol
	push	edi
	mov	edi,preprocessor_directives
	call	get_symbol
	pop	edi
	jc	not_preprocessor_directive
	mov	byte [edx-2],0x3B
	movzx	ebx,ax
	add	ebx,preprocessor
	xor	eax,eax
	jmp	ebx
      not_preprocessor_directive:
	mov	al,cl
	xor	ah,ah
	call	get_macro
	jc	not_macro
	mov	byte [edx-2],0x3B
	mov	dword [struc_name],0
	jmp	use_macro
      not_macro:
	mov	dword [struc_name],esi
	add	esi,ecx
	lodsb
	cmp	al,':
	je	preprocess_instruction
	cmp	al,0x1A
	jne	not_preprocessor_symbol
	cmp	dword [esi],3+('e<<8)+('q<<16)+('u<<24)  ; Same multibyte character constant order in fasm and NASM.
	je	define_symbolic_constant
	lodsb
	mov	ah,1
	call	get_macro
	jc	not_preprocessor_symbol
	mov	byte [edx-2],':
	mov	al,0x3B
	xchg	al,[edx-1]
	dec	al
	mov	[edx],al
	jmp	use_macro
      not_preprocessor_symbol:
	mov	esi,dword [current_line]
	add	esi,12
	call	process_symbolic_constants
      line_preprocessed:
	pop	esi
	pop	ecx
	pop	dword [struc_name]
	ret
get_macro:
	mov	edx,esi
	mov	ebp,edi
	mov	ebx,dword [additional_memory]
      check_macro:
	mov	cl,al
	cmp	ebx,dword [macros_list]
	je	no_macro_found
	sub	ebx,8
	cmp	ax,[ebx]
	jne	check_macro
	mov	edi,[ebx+4]
	repe
	cmpsb
	je	macro_ok
	mov	esi,edx
	jmp	check_macro
      no_macro_found:
	mov	edi,ebp
	stc
	ret
      macro_ok:
	mov	edi,ebp
	clc
	ret
process_symbolic_constants:
	mov	ebp,esi
	lodsb
	cmp	al,0x1A
	je	check_symbol
	cmp	al,0x22
	je	ignore_string
	or	al,al
	jnz	process_symbolic_constants
	dec	esi
	ret
      ignore_string:
	lodsd
	add	esi,eax
	jmp	process_symbolic_constants
      check_symbol:
	movzx	ecx,byte [esi]
	inc	esi
	call	replace_symbolic_constant
	jnc	process_after_replaced
	add	esi,ecx
	jmp	process_symbolic_constants
      replace_symbolic_constant:
	push	edi
	mov	ebx,esi
	mov	eax,ecx
	mov	edx,dword [labels_list]
      scan_symbolic_constants:
	mov	ecx,eax
	mov	esi,ebx
	cmp	edx,dword [additional_memory_end]
	je	not_symbolic_constant
	cmp	al,[edx]
	jne	next_symbolic_constant
	mov	edi,[edx+4]
	repe
	cmpsb
	je	symbolic_constant_found
      next_symbolic_constant:
	add	edx,16
	jmp	scan_symbolic_constants
      not_symbolic_constant:
	pop	edi
	stc
	ret
      symbolic_constant_found:
	pop	edi
	mov	ecx,[edx+8]
	mov	edx,[edx+12]
	xchg	esi,edx
	xor	eax,eax
	shr	ecx,1
	rcl	al,1
	shr	ecx,1
	rcl	ah,1
	rep
	movsd
	mov	cl,ah
	rep
	movsw
	mov	cl,al
	rep
	movsb
	mov	esi,edx
	clc
	ret
      process_after_replaced:
	lodsb
	cmp	al,0x1A
	je	symbol_after_replaced
	stosb
	cmp	al,0x22
	je	string_after_replaced
	or	al,al
	jnz	process_after_replaced
	mov	ecx,edi
	sub	ecx,esi
	mov	edi,ebp
	xor	eax,eax
	shr	ecx,1
	rcl	al,1
	shr	ecx,1
	rcl	ah,1
	rep
	movsd
	mov	cl,ah
	rep
	movsw
	mov	cl,al
	rep
	movsb
	ret
      string_after_replaced:
	lodsd
	stosd
	mov	ecx,eax
	rep
	movsb
	jmp	process_after_replaced
      symbol_after_replaced:
	movzx	ecx,byte [esi]
	inc	esi
	call	replace_symbolic_constant
	jnc	process_after_replaced
	mov	al,0x1A
	mov	ah,cl
	stosw
	rep
	movsb
	jmp	process_after_replaced
include_file:
	lodsb
	cmp	al,0x22
	jne	invalid_argument
	lodsd
	mov	edx,esi
	add	esi,eax
	cmp	byte [esi],0
	jne	extra_characters_on_line
	call	preprocess_file
	jc	file_not_found
	jmp	line_preprocessed
define_symbolic_constant:
	add	esi,4
	push	esi
	call	process_symbolic_constants
	pop	ebx
	mov	edx,dword [labels_list]
	sub	edx,16
	cmp	edx,dword [additional_memory]
	jb	out_of_memory
	mov	dword [labels_list],edx
	mov	ecx,edi
	dec	ecx
	sub	ecx,ebx
	mov	[edx+8],ecx
	mov	[edx+12],ebx
	mov	ebx,dword [struc_name]
	mov	byte [ebx-2],0x3B
	mov	al,[ebx-1]
	mov	[edx],al
	mov	[edx+4],ebx
	jmp	line_preprocessed
define_struc:
	or	ah,1
define_macro:
	cmp	byte [macro_status],0
	jne	unexpected_instruction
	lodsb
	cmp	al,0x1A
	jne	invalid_name
	lodsb
	mov	ebx,dword [additional_memory]
	mov	[ebx],ax
	mov	[ebx+4],esi
	add	ebx,8
	cmp	ebx,dword [labels_list]
	jae	out_of_memory
	mov	dword [additional_memory],ebx
	movzx	eax,al
	add	esi,eax
	mov	byte [macro_status],1
	xor	bl,bl
	lodsb
	or	al,al
	jz	line_preprocessed
	cmp	al,'{
	je	found_macro_block
	dec	esi
      skip_macro_arguments:
	lodsb
	cmp	al,0x1A
	je	skip_macro_argument
	cmp	al,'[
	jne	invalid_macro_arguments
	xor	bl,-1
	jz	invalid_macro_arguments
	lodsb
	cmp	al,0x1A
	jne	invalid_macro_arguments
      skip_macro_argument:
	movzx	eax,byte [esi]
	inc	esi
	add	esi,eax
	lodsb
	cmp	al,',
	je	skip_macro_arguments
	cmp	al,']
	jne	end_macro_arguments
	lodsb
	not	bl
      end_macro_arguments:
	or	bl,bl
	jnz	invalid_macro_arguments
	or	al,al
	jz	line_preprocessed
	cmp	al,'{
	je	found_macro_block
	jmp	invalid_macro_arguments
      find_macro_block:
	add	esi,2
	lodsb
	or	al,al
	jz	line_preprocessed
	cmp	al,'{
	jne	unexpected_characters
      found_macro_block:
	mov	byte [macro_status],2
      skip_macro_block:
	lodsb
	cmp	al,0x1A
	je	skip_macro_symbol
	cmp	al,0x3B
	je	skip_macro_symbol
	cmp	al,0x22
	je	skip_macro_string
	or	al,al
	jz	line_preprocessed
	cmp	al,'}
	jne	skip_macro_block
	lodsb
	or	al,al
	jnz	extra_characters_on_line
	mov	byte [macro_status],0
	jmp	line_preprocessed
      skip_macro_symbol:
	movzx	eax,byte [esi]
	inc	esi
	add	esi,eax
	jmp	skip_macro_block
      skip_macro_string:
	lodsd
	add	esi,eax
	jmp	skip_macro_block
purge_macro:
	lodsb
	cmp	al,0x1A
	jne	invalid_name
	lodsb
	xor	ah,ah
	call	get_macro
	jc	macro_purged
	or	byte [ebx+1],0x80
      macro_purged:
	lodsb
	cmp	al,',
	je	purge_macro
	or	al,al
	jnz	extra_characters_on_line
	jmp	line_preprocessed
use_macro:
	push	dword [macro_constants]
	push	dword [macro_block]
	push	dword [macro_block_line_number]
	push	dword [counter]
	push	dword [counter_limit]
	or	byte [macro_status],0x80
	or	byte [ebx+1],0x80
	mov	edx,esi
	movzx	esi,byte [ebx]
	add	esi,[ebx+4]
	push	edi
	mov	edi,dword [additional_memory]
	mov	dword [macro_constants],edi
	mov	dword [counter],0
      process_macro_arguments:
	lodsb
	or	al,al
	jz	find_macro_instructions
	cmp	al,'{
	je	macro_instructions_start
	cmp	al,'[
	jne	get_macro_argument
	mov	ebp,esi
	inc	esi
	inc	dword [counter]
      get_macro_argument:
	movzx	eax,byte [esi]
	inc	esi
	mov	[edi+4],esi
	add	esi,eax
	ror	eax,8
	or	eax,dword [counter]
	rol	eax,8
	mov	[edi],eax
	xchg	esi,edx
	mov	[edi+12],esi
      get_argument_value:
	lodsb
	or	al,al
	jz	argument_value_end
	cmp	al,',
	je	argument_value_end
	cmp	al,0x22
	je	argument_string
	cmp	al,0x1A
	jne	get_argument_value
	movzx	eax,byte [esi]
	inc	esi
	add	esi,eax
	jmp	get_argument_value
      argument_string:
	lodsd
	add	esi,eax
	jmp	get_argument_value
      argument_value_end:
	dec	esi
	mov	eax,esi
	sub	eax,[edi+12]
	mov	[edi+8],eax
	xchg	esi,edx
	add	edi,16
	cmp	edi,dword [labels_list]
	jae	out_of_memory
	lodsb
	cmp	al,',
	je	next_argument
	cmp	al,']
	je	next_arguments_group
	dec	esi
	jmp	arguments_end
      next_argument:
	cmp	byte [edx],',
	jne	process_macro_arguments
	inc	edx
	jmp	process_macro_arguments
      next_arguments_group:
	cmp	byte [edx],',
	jne	arguments_end
	inc	edx
	inc	dword [counter]
	mov	esi,ebp
	jmp	process_macro_arguments
      arguments_end:
	lodsb
	cmp	al,'{
	je	macro_instructions_start
      find_macro_instructions:
	add	esi,14
	lodsb
	or	al,al
	jz	find_macro_instructions
	cmp	al,'{
	jne	unexpected_characters
      macro_instructions_start:
	cmp	byte [edx],0
	jne	invalid_macro_arguments
	mov	dword [additional_memory],edi
	pop	edi
	mov	ecx,0x80000000
	push	dword [current_line]
	mov	dword [macro_block],esi
	mov	dword [macro_block_line_number],ecx
	mov	eax,1
	xchg	eax,dword [counter]
	mov	dword [counter_limit],eax
	or	eax,eax
	jnz	process_macro_line
	mov	dword [counter_limit],1
      process_macro_line:
	mov	dword [current_line],edi
	mov	eax,[ebx+4]
	dec	eax
	stosd
	mov	eax,ecx
	stosd
	mov	eax,[esp]
	stosd
	or	byte [macro_status],0x40
	push	ebx
	push	ecx
      process_macro:
	lodsb
	cmp	al,'}
	je	macro_line_processed
	or	al,al
	jz	macro_line_processed
	cmp	al,0x1A
	je	process_macro_symbol
	and	byte [macro_status],~0x40
	stosb
	cmp	al,0x22
	jne	process_macro
      copy_macro_string:
	mov	ecx,[esi]
	add	ecx,4
	rep
	movsb
	jmp	process_macro
      process_macro_symbol:
	push	esi
	push	edi
	test	byte [macro_status],0x40
	jz	not_macro_directive
	movzx	ecx,byte [esi]
	inc	esi
	mov	edi,macro_directives
	call	get_symbol
	jnc	process_macro_directive
	dec	esi
	jmp	not_macro_directive
      process_macro_directive:
	movzx	edx,ax
	add	edx,preprocessor
	pop	edi
	pop	eax
	mov	byte [edi],0
	inc	edi
	pop	ecx
	pop	ebx
	jmp	edx
      not_macro_directive:
	and	byte [macro_status],~0x40
	mov	eax,dword [counter]
	or	eax,eax
	jnz	check_for_macro_constant
	inc	eax
      check_for_macro_constant:
	shl	eax,8
	mov	al,[esi]
	inc	esi
	movzx	ebp,al
	mov	edx,dword [macro_constants]
	mov	ebx,esi
      scan_macro_constants:
	cmp	edx,dword [additional_memory]
	je	not_macro_constant
	cmp	eax,[edx]
	je	try_macro_constant
	cmp	ebp,[edx]
	jne	next_macro_constant
      try_macro_constant:
	mov	ecx,ebp
	mov	edi,[edx+4]
	repe
	cmpsb
	je	macro_constant_found
	mov	esi,ebx
      next_macro_constant:
	add	edx,16
	jmp	scan_macro_constants
      macro_constant_found:
	cmp	dword [counter],0
	jne	replace_macro_constant
	mov	eax,[edx]
	shr	eax,8
	or	eax,eax
	jz	replace_macro_constant
	cmp	eax,dword [counter_limit]
	je	replace_macro_constant
	pop	edi
	mov	ecx,[edx+8]
	mov	esi,[edx+12]
	rep
	movsb
	mov	byte [edi],',
	inc	edi
	mov	esi,ebx
	inc	eax
	shl	eax,8
	mov	al,[esi-1]
	push	edi
	jmp	scan_macro_constants
      replace_macro_constant:
	pop	edi
	pop	eax
	mov	ecx,[edx+8]
	mov	edx,[edx+12]
	xchg	esi,edx
	rep
	movsb
	mov	esi,edx
	jmp	process_macro
      not_macro_constant:
	pop	edi
	pop	esi
	mov	al,0x1A
	stosb
	mov	al,[esi]
	inc	esi
	stosb
	cmp	byte [esi],'.
	jne	copy_macro_symbol
	mov	ebx,dword [struc_name]
	or	ebx,ebx
	jz	copy_macro_symbol
	xchg	esi,ebx
	movzx	ecx,byte [esi-1]
	add	[edi-1],cl
	jc	name_too_long
	rep
	movsb
	xchg	esi,ebx
      copy_macro_symbol:
	movzx	ecx,al
	rep
	movsb
	jmp	process_macro
      macro_line_processed:
	mov	byte [edi],0
	inc	edi
	push	eax
	call	preprocess_line
	pop	eax
	pop	ecx
	pop	ebx
	cmp	al,'}
	je	macro_block_processed
      process_next_line:
	inc	ecx
	add	esi,14
	jmp	process_macro_line
      local_symbols:
	lodsb
	cmp	al,0x1A
	jne	invalid_argument
	push	edi
	push	ecx
	movzx	ecx,byte [esi]
	inc	esi
	mov	edx,dword [additional_memory]
	mov	eax,dword [counter]
	shl	eax,8
	mov	al,cl
	mov	[edx],eax
	mov	[edx+4],esi
	movzx	eax,byte [_counter]
	mov	edi,dword [memory_end]
	sub	edi,eax
	sub	edi,ecx
	sub	edi,3
	mov	dword [memory_end],edi
	mov	[edx+12],edi
	add	al,cl
	jc	name_too_long
	inc	al
	jz	name_too_long
	mov	byte [edi],0x1A
	inc	edi
	mov	[edi],al
	inc	edi
	add	eax,2
	mov	[edx+8],eax
	add	edx,16
	cmp	edx,dword [labels_list]
	jae	out_of_memory
	mov	dword [additional_memory],edx
	rep
	movsb
	mov	al,'?
	stosb
	movzx	ecx,byte [_counter]
	push	esi
	mov	esi,_counter+1
	rep
	movsb
	pop	esi
	pop	ecx
	pop	edi
	cmp	edi,dword [memory_end]
	jae	out_of_memory
	lodsb
	cmp	al,',
	je	local_symbols
	cmp	al,'}
	je	macro_block_processed
	or	al,al
	jnz	extra_characters_on_line
	jmp	process_next_line
      common_block:
	call	close_macro_block
	jc	process_macro_line
	mov	dword [counter],0
	jmp	new_macro_block
      forward_block:
	call	close_macro_block
	jc	process_macro_line
	mov	dword [counter],1
	jmp	new_macro_block
      reverse_block:
	call	close_macro_block
	jc	process_macro_line
	mov	eax,dword [counter_limit]
	or	eax,0x80000000
	mov	dword [counter],eax
      new_macro_block:
	mov	dword [macro_block],esi
	mov	dword [macro_block_line_number],ecx
	jmp	process_macro_line
      close_macro_block:
	push	ecx
	mov	eax,_counter
	call	increase_counter
	pop	ecx
	cmp	dword [counter],0
	je	block_closed
	jl	reverse_counter
	mov	eax,dword [counter]
	cmp	eax,dword [counter_limit]
	je	block_closed
	inc	dword [counter]
	jmp	continue_block
      reverse_counter:
	mov	eax,dword [counter]
	dec	eax
	cmp	eax,0x80000000
	je	block_closed
	mov	dword [counter],eax
      continue_block:
	mov	esi,dword [macro_block]
	mov	ecx,dword [macro_block_line_number]
	stc
	ret
      block_closed:
	clc
	ret
      macro_block_processed:
	call	close_macro_block
	jc	process_macro_line
	and	byte [ebx+1],(~0x80)&0xff
	pop	dword [current_line]
	mov	eax,dword [macro_constants]
	mov	dword [additional_memory],eax
	mov	byte [macro_status],0
	pop	dword [counter_limit]
	pop	dword [counter]
	pop	dword [macro_block_line_number]
	pop	dword [macro_block]
	pop	dword [macro_constants]
	jmp	line_preprocessed

increase_counter:
	movzx	ecx,byte [eax]
      counter_loop:
	call	increase_digit
	jnc	counter_ok
	mov	byte [eax+ecx],'0
	loop	counter_loop
      counter_ok:
	ret
      increase_digit:
	inc	byte [eax+ecx]
	cmp	byte [eax+ecx],':
	jb	digit_increased
	je	letter_digit
	cmp	byte [eax+ecx],'f
	jbe	digit_increased
	stc
	ret
      letter_digit:
	mov	byte [eax+ecx],'a
      digit_increased:
	clc
	ret

;%include '../parser.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

parser:
	mov	eax,dword [memory_end]
	mov	dword [labels_list],eax
	mov	dword [current_locals_prefix],0
	mov	esi,dword [source_start]
	mov	edi,dword [code_start]
	push	dword [additional_memory]
     parser_loop:
	mov	dword [current_line],esi
	cmp	edi,dword [labels_list]
	jae	out_of_memory
	mov	al,0xF
	stosb
	mov	eax,esi
	stosd
	add	esi,12
	call	parse_line
	cmp	esi,dword [code_start]
	jb	parser_loop
	xor	al,al
	stosb
	pop	dword [additional_memory]
	mov	eax,dword [code_start]
	mov	dword [source_start],eax
	mov	dword [code_start],edi
	ret

parse_line:
	mov	byte [parenthesis_stack],0
      instruction_start:
	cmp	byte [esi],0x1A
	jne	empty_instruction
	push	edi
	inc	esi
	movzx	ecx,byte [esi]
	inc	esi
	cmp	byte [esi+ecx],':
	je	simple_label
	push	esi
	push	ecx
	add	esi,ecx
	cmp	byte [esi],0x1A
	je	check_for_data_label
	cmp	byte [esi],'=
	je	constant_label
	pop	ecx
	pop	esi
	jmp	get_main_instruction
      check_for_data_label:
	inc	esi
	movzx	ecx,byte [esi]
	inc	esi
	push	edi
	mov	edi,data_directives
	call	get_symbol
	pop	edi
	jnc	data_label
	pop	ecx
	pop	esi
      get_main_instruction:
	call	get_instruction
	jnc	parse_instruction
	mov	edi,data_directives
	call	get_symbol
	jnc	data_instruction
	mov	edi,symbols
	call	get_symbol
	pop	edi
	jc	unknown_instruction
	stosw
	jmp	parse_arguments
      data_instruction:
	movzx	ebx,ah
	mov	bx,[ebx*2+data_handlers]  ; Offset must come last.
	jmp	parse_instruction
      unknown_instruction:
	sub	esi,2
	jmp	parse_arguments
      constant_label:
	pop	ecx
	pop	esi
	pop	edi
	call	identify_label
	mov	byte [edi],3
	inc	edi
	stosd
	xor	al,al
	stosb
	inc	esi
	jmp	parse_arguments
      data_label:
	pop	ecx
	pop	ebx
	pop	edi
	push	ax
	push	esi
	mov	esi,ebx
	call	identify_label
	mov	byte [edi],2
	inc	edi
	stosd
	pop	esi
	pop	ax
	stosb
	push	edi
	jmp	data_instruction
      simple_label:
	pop	edi
	call	identify_label
	mov	byte [edi],2
	inc	edi
	stosd
	inc	esi
	xor	al,al
	stosb
	jmp	instruction_start
      identify_label:
	cmp	byte [esi],'.
	je	local_label_name
	call	get_label_id
	mov	ebx,[eax+4]
	dec	ebx
	mov	dword [current_locals_prefix],ebx
	ret
      local_label_name:
	call	get_label_id
	ret
      parse_prefix_instruction:
	cmp	byte [esi],0x1A
	jne	parse_arguments
	push	edi
	inc	esi
	movzx	ecx,byte [esi]
	inc	esi
	jmp	get_main_instruction
      parse_label_directive:
	push	edi
	lodsb
	cmp	al,0x1A
	jne	invalid_argument
	movzx	ecx,byte [esi]
	lodsb
	pop	edi
	mov	al,2
	stosb
	call	identify_label
	stosd
	xor	al,al
	stosb
	jmp	parse_arguments
      parse_instruction:
	pop	edi
	mov	dl,al
	mov	al,1
	stosb
	mov	ax,bx
	stosw
	mov	al,dl
	stosb
	cmp	bx,prefix_instruction-assembler
	je	parse_prefix_instruction
	cmp	bx,end_directive-assembler
	je	parse_prefix_instruction
	cmp	bx,label_directive-assembler
	je	parse_label_directive
	cmp	bx,load_directive-assembler
	je	parse_label_directive
      parse_arguments:
	lodsb
	cmp	al,':
	je	instruction_separator
	cmp	al,',
	je	separator
	cmp	al,'=
	je	separator
	cmp	al,'|
	je	separator
	cmp	al,'&
	je	separator
	cmp	al,'~
	je	separator
	cmp	al,'>
	je	greater
	cmp	al,'<
	je	less
	cmp	al,')
	je	close_expression
	or	al,al
	jz	line_parsed
	cmp	al,'[
	je	address_argument
	cmp	al,']
	je	separator
	dec	esi
	cmp	al,0x1A
	jne	expression_argument
	push	edi
	mov	edi,directive_operators
	call	get_operator
	or	al,al
	jnz	operator_argument
	inc	esi
	movzx	ecx,byte [esi]
	inc	esi
	mov	edi,symbols
	call	get_symbol
	jnc	symbol_argument
	mov	edi,formatter_symbols
	call	get_symbol
	jnc	symbol_argument
	cmp	ecx,1
	jne	check_argument
	cmp	byte [esi],'?
	jne	check_argument
	pop	edi
	movsb
	jmp	argument_parsed
      symbol_argument:
	pop	edi
	stosw
	jmp	argument_parsed
      operator_argument:
	pop	edi
	stosb
	cmp	al,0x80
	je	forced_expression
	jmp	argument_parsed
      check_argument:
	push	esi
	push	ecx
	sub	esi,2
	mov	edi,single_operand_operators
	call	get_operator
	pop	ecx
	pop	esi
	or	al,al
	jnz	not_instruction
	call	get_instruction
	jnc	parse_instruction
	mov	edi,data_directives
	call	get_symbol
	jnc	data_instruction
      not_instruction:
	pop	edi
	sub	esi,2
      expression_argument:
	cmp	byte [esi],0x22
	jne	not_string
	mov	eax,[esi+1]
	cmp	eax,8
	ja	string_argument
	lea	ebx,[esi+eax+5]  ; Offset must come last.
	push	ebx
	push	ecx
	push	esi
	push	edi
	mov	al,'(
	stosb
	call	convert_expression
	mov	al,')
	stosb
	pop	eax
	pop	edx
	pop	ecx
	pop	ebx
	cmp	esi,ebx
	jne	expression_parsed
	mov	edi,eax
	mov	esi,edx
      string_argument:
	inc	esi
	mov	ax,'(
	stosw
	lodsd
	mov	ecx,eax
	stosd
	shr	ecx,1
	jnc	string_movsb_ok
	movsb
      string_movsb_ok:
	shr	ecx,1
	jnc	string_movsw_ok
	movsw
      string_movsw_ok:
	rep
	movsd
	xor	al,al
	stosb
	jmp	argument_parsed
      not_string:
	cmp	byte [esi],'(
	jne	parse_expression
	push	esi
	push	edi
	inc	esi
	mov	al,'{
	stosb
	inc	byte [parenthesis_stack]
	jmp	parse_arguments
      parse_expression:
      forced_expression:
	mov	al,'(
	stosb
      expression:
	call	convert_expression
	mov	al,')
	stosb
	jmp	expression_parsed
      address_argument:
	mov	al,'[
	stosb
	cmp	word [esi],0x21A
	jne	convert_address
	push	esi
	add	esi,4
	lea	ebx,[esi+1]
	cmp	byte [esi],':
	pop	esi
	jne	convert_address
	add	esi,2
	mov	ecx,2
	push	ebx
	push	edi
	mov	edi,symbols
	call	get_symbol
	pop	edi
	pop	esi
	jc	invalid_address
	cmp	al,0x10
	jne	invalid_address
	mov	al,ah
	and	ah,%11110000
	cmp	ah,0x60
	jne	invalid_address
	stosb
      convert_address:
	cmp	byte [esi],0x1A
	jne	convert_address_value
	push	esi
	lodsw
	movzx	ecx,ah
	push	edi
	mov	edi,address_sizes
	call	get_symbol
	pop	edi
	jc	no_size_prefix
	mov	al,ah
	add	al,0x70
	stosb
	add	esp,4
	jmp	convert_address_value
      no_size_prefix:
	pop	esi
      convert_address_value:
	call	convert_expression
	lodsb
	cmp	al,']
	jne	invalid_address
	stosb
	jmp	argument_parsed
      close_expression:
	mov	al,'}
      separator:
	stosb
	jmp	argument_parsed
      instruction_separator:
	stosb
	jmp	instruction_start
      greater:
	cmp	byte [esi],'=
	jne	separator
	inc	esi
	mov	al,0xf2
	jmp	separator
      less:
	cmp	byte [edi-1],0x83
	je	separator
	cmp	byte [esi],'>
	je	not_equal
	cmp	byte [esi],'=
	jne	separator
	inc	esi
	mov	al,0xf3
	jmp	separator
      not_equal:
	inc	esi
	mov	al,0xf6
	jmp	separator
      argument_parsed:
	cmp	byte [parenthesis_stack],0
	je	parse_arguments
	dec	byte [parenthesis_stack]
	add	esp,8
	jmp	argument_parsed
      expression_parsed:
	cmp	byte [parenthesis_stack],0
	je	parse_arguments
	cmp	byte [esi],')
	jne	argument_parsed
	dec	byte [parenthesis_stack]
	pop	edi
	pop	esi
	jmp	parse_expression
      empty_instruction:
	lodsb
	or	al,al
	jz	line_parsed
	cmp	al,':
	je	empty_label
	cmp	al,0x3B
	je	skip_preprocessed_symbol
	dec	esi
	jmp	parse_arguments
      empty_label:
	mov	eax,_counter
	call	increase_counter
	mov	dword [current_locals_prefix],eax
	jmp	instruction_start
      skip_preprocessed_symbol:
	lodsb
	movzx	eax,al
	add	esi,eax
      skip_next:
	lodsb
	or	al,al
	jz	line_parsed
	cmp	al,0x1A
	je	skip_preprocessed_symbol
	cmp	al,0x22
	je	skip_preprocessed_string
	jmp	skip_next
      skip_preprocessed_string:
	lodsd
	add	esi,eax
	jmp	skip_next
      line_parsed:
	cmp	byte [parenthesis_stack],0
	jne	invalid_expression
	ret

;%include '../assemble.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

assembler:
	mov	edi,dword [labels_list]
	mov	ecx,dword [memory_end]
	sub	ecx,edi
	shr	ecx,2
	xor	eax,eax
	rep
	stosd
	mov	byte [current_pass],0
	mov	dword [number_of_sections],0
	mov	byte [times_working],0
      assembler_loop:
	mov	eax,dword [labels_list]
	mov	dword [display_buffer],eax
	mov	eax,dword [additional_memory_end]
	mov	dword [structures_buffer],eax
	mov	byte [next_pass_needed],0
	mov	byte [output_format],0
	mov	dword [format_flags],0
	mov	byte [code_type],16
	mov	byte [reloc_labels],0
	mov	byte [virtual_data],0
	mov	esi,dword [source_start]
	mov	edi,dword [code_start]
	mov	dword [org_start],edi
	mov	dword [org_sib],0
	mov	dword [error_line],0
	mov	dword [counter],0
	mov	dword [number_of_relocations],0
      pass_loop:
	call	assemble_line
	jnc	pass_loop
	mov	eax,dword [structures_buffer]
	cmp	eax,dword [additional_memory_end]
	jne	unexpected_end_of_file
	jmp	pass_done
      pass_done:
	cmp	byte [next_pass_needed],0
	je	assemble_done
      next_pass:
	inc	byte [current_pass]
	cmp	byte [current_pass],100
	jae	code_cannot_be_generated
	jmp	assembler_loop
      pass_error:
	mov	dword [current_line],eax
	jmp	dword [error]
      assemble_done:
	mov	eax,dword [error_line]
	or	eax,eax
	jnz	pass_error
	call	flush_display_buffer
      assemble_ok:
	mov	eax,edi
	sub	eax,dword [code_start]
	mov	dword [real_code_size],eax
	cmp	edi,dword [undefined_data_end]
	jne	calculate_code_size
	mov	edi,dword [undefined_data_start]
      calculate_code_size:
	sub	edi,dword [code_start]
	mov	dword [code_size],edi
	mov	dword [written_size],0
	mov	edx,dword [output_file]
	call	create
	jc	write_failed
      write_code:
	mov	edx,dword [code_start]
	mov	ecx,dword [code_size]
	add	dword [written_size],ecx
	call	write
	jc	write_failed
	call	close
	ret

assemble_line:
	mov	eax,dword [display_buffer]
	sub	eax,0x100
	cmp	edi,eax
	jae	out_of_memory
	lodsb
	or	al,al
	jz	source_end
	cmp	al,1
	je	assemble_instruction
	cmp	al,2
	je	define_label
	cmp	al,3
	je	define_constant
	cmp	al,0xF
	je	new_line
	cmp	al,0x13
	je	code_type_setting
	cmp	al,0x10
	jne	illegal_instruction
	lodsb
	mov	ah,al
	shr	ah,4
	cmp	ah,6
	jne	illegal_instruction
	and	al,%1111
	mov	byte [segment_register],al
	call	store_segment_prefix
	jmp	assemble_line
      code_type_setting:
	lodsb
	mov	byte [code_type],al
	jmp	line_assembled
      new_line:
	lodsd
	mov	dword [current_line],eax
	jmp	assemble_line
      define_label:
	lodsd
	mov	ebx,eax
	lodsb
	mov	dl,al
	xor	ch,ch
	cmp	byte [reloc_labels],0
	je	label_reloc_ok
	mov	ch,2
      label_reloc_ok:
	xchg	ch,[ebx+11]
	mov	al,byte [current_pass]
	test	byte [ebx+8],1
	jz	new_label
	cmp	al,[ebx+9]
	je	symbol_already_defined
	mov	[ebx+9],al
	mov	eax,edi
	sub	eax,dword [org_start]
	xchg	[ebx],eax
	cdq
	xchg	[ebx+4],edx
	mov	ebp,dword [org_sib]
	xchg	[ebx+12],ebp
	cmp	byte [current_pass],0
	je	assemble_line
	cmp	eax,[ebx]
	jne	changed_label
	cmp	edx,[ebx+4]
	jne	changed_label
	cmp	ebp,[ebx+12]
	jne	changed_label
	cmp	ch,[ebx+11]
	jne	changed_label
	jmp	assemble_line
      changed_label:
	or	byte [next_pass_needed],-1
	jmp	assemble_line
      new_label:
	or	byte [ebx+8],1
	mov	[ebx+9],al
	mov	byte [ebx+10],dl
	mov	eax,edi
	sub	eax,dword [org_start]
	mov	[ebx],eax
	cdq
	mov	dword [ebx+4],edx
	mov	eax,dword [org_sib]
	mov	[ebx+12],eax
	jmp	assemble_line
      define_constant:
	lodsd
	push	eax
	lodsb
	push	ax
	call	get_value
	pop	bx
	mov	ch,bl
	pop	ebx
      make_constant:
	mov	cl,byte [current_pass]
	test	byte [ebx+8],1
	jz	new_constant
	cmp	cl,[ebx+9]
	jne	redefine_constant
	test	byte [ebx+8],2
	jz	symbol_already_defined
	or	byte [ebx+8],4
      redefine_constant:
	mov	[ebx+9],cl
	xchg	[ebx],eax
	xchg	[ebx+4],edx
	mov	cl,byte [value_type]
	xchg	[ebx+11],cl
	cmp	byte [current_pass],0
	je	assemble_line
	cmp	eax,[ebx]
	jne	changed_constant
	cmp	edx,[ebx+4]
	jne	changed_constant
	cmp	cl,[ebx+11]
	jne	changed_constant
	jmp	assemble_line
      changed_constant:
	test	byte [ebx+8],4
	jnz	assemble_line
	or	byte [next_pass_needed],-1
	jmp	assemble_line
      new_constant:
	or	byte [ebx+8],1+2
	mov	word [ebx+9],cx
	mov	[ebx],eax
	mov	[ebx+4],edx
	mov	cl,byte [value_type]
	mov	[ebx+11],cl
	jmp	assemble_line
      assemble_instruction:
	mov	byte [operand_size],0
	mov	byte [forced_size],0
	lodsw
	movzx	ebx,ax
	add	ebx,assembler
	lodsb
	jmp	ebx
      instruction_assembled:
	mov	al,[esi]
	cmp	al,0xF
	je	line_assembled
	or	al,al
	jnz	extra_characters_on_line
      line_assembled:
	clc
	ret
      source_end:
	stc
	ret
skip_line:
	call	skip_symbol
	jnc	skip_line
	ret
skip_symbol:
	lodsb
	or	al,al
	jz	nothing_to_skip
	cmp	al,0xF
	je	nothing_to_skip
	cmp	al,1
	je	skip_instruction
	cmp	al,2
	je	skip_label
	cmp	al,3
	je	skip_label
	cmp	al,0x20
	jb	skip_assembler_symbol
	cmp	al,'(
	je	skip_expression
	cmp	al,'[
	je	skip_address
      skip_done:
	clc
	ret
      skip_label:
	add	esi,2
      skip_instruction:
	add	esi,2
      skip_assembler_symbol:
	inc	esi
	jmp	skip_done
      skip_address:
	mov	al,[esi]
	and	al,%11110000
	cmp	al,0x60
	jb	skip_expression
	cmp	al,0x70
	ja	skip_expression
	inc	esi
	jmp	skip_address
      skip_expression:
	lodsb
	or	al,al
	jz	skip_string
	cmp	al,'.
	je	skip_fp_value
	cmp	al,')
	je	skip_done
	cmp	al,']
	je	skip_done
	cmp	al,0xF
	je	skip_expression
	cmp	al,0x10
	je	skip_register
	cmp	al,0x11
	je	skip_label_value
	cmp	al,0x80
	jae	skip_expression
	movzx	eax,al
	add	esi,eax
	jmp	skip_expression
      skip_label_value:
	add	esi,3
      skip_register:
	inc	esi
	jmp	skip_expression
      skip_fp_value:
	add	esi,12
	jmp	skip_done
      skip_string:
	lodsd
	add	esi,eax
	inc	esi
	jmp	skip_done
      nothing_to_skip:
	dec	esi
	stc
	ret

org_directive:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	mov	byte [reloc_labels],0
	mov	dl,byte [value_type]
	or	dl,dl
	jz	org_ok
	cmp	dl,2
	jne	invalid_use_of_symbol
	or	byte [reloc_labels],-1
      org_ok:
	mov	ecx,edi
	sub	ecx,eax
	mov	dword [org_start],ecx
	mov	dword [org_sib],0
	jmp	instruction_assembled
label_directive:
	lodsb
	cmp	al,2
	jne	invalid_argument
	lodsd
	inc	esi
	mov	ebx,eax
	xor	ch,ch
	cmp	byte [esi],0x11
	jne	label_size_ok
	lodsw
	mov	ch,ah
      label_size_ok:
	mov	eax,edi
	sub	eax,dword [org_start]
	mov	ebp,dword [org_sib]
	cmp	byte [esi],0x80
	jne	define_free_label
	inc	esi
	lodsb
	cmp	al,'(
	jne	invalid_argument
	mov	byte [ebx+11],0
	push	ebx
	push	cx
	cmp	byte [esi],'.
	je	invalid_value
	call	get_address_value
	or	bh,bh
	setnz	ch
	xchg	ch,cl
	mov	bp,cx
	shl	ebp,16
	mov	bl,bh
	mov	bp,bx
	pop	cx
	pop	ebx
	mov	dl,al
	mov	dh,byte [value_type]
	cmp	dh,1
	je	invalid_use_of_symbol
	jb	free_label_reloc_ok
      define_free_label:
	xor	dh,dh
	cmp	byte [reloc_labels],0
	je	free_label_reloc_ok
	mov	dh,2
      free_label_reloc_ok:
	xchg	dh,[ebx+11]
	mov	cl,byte [current_pass]
	test	byte [ebx+8],1
	jz	new_free_label
	cmp	cl,[ebx+9]
	je	symbol_already_defined
	mov	ch,dh
	mov	[ebx+9],cl
	xchg	[ebx],eax
	cdq
	xchg	[ebx+4],edx
	xchg	[ebx+12],ebp
	cmp	byte [current_pass],0
	je	instruction_assembled
	cmp	eax,[ebx]
	jne	changed_free_label
	cmp	edx,[ebx+4]
	jne	changed_free_label
	cmp	ebp,[ebx+12]
	jne	changed_free_label
	cmp	ch,[ebx+11]
	jne	changed_free_label
	jmp	instruction_assembled
      changed_free_label:
	or	byte [next_pass_needed],-1
	jmp	instruction_assembled
      new_free_label:
	or	byte [ebx+8],1
	mov	[ebx+9],cl
	mov	byte [ebx+10],ch
	mov	[ebx],eax
	cdq
	mov	dword [ebx+4],edx
	mov	[ebx+12],ebp
	jmp	instruction_assembled
load_directive:
	lodsb
	cmp	al,2
	jne	invalid_argument
	lodsd
	inc	esi
	push	eax
	mov	al,1
	cmp	byte [esi],0x11
	jne	load_size_ok
	lodsb
	lodsb
      load_size_ok:
	cmp	al,8
	ja	invalid_value
	mov	byte [operand_size],al
	lodsb
	cmp	al,0x82
	jne	invalid_argument
	lodsw
	cmp	ax,'(
	jne	invalid_argument
	lea	edx,[esi+4]
	mov	eax,[esi]
	lea	esi,[esi+eax+5]  ; Offset must come last.
	call	open
	jc	file_not_found
	mov	al,2
	xor	edx,edx
	call	lseek
	xor	edx,edx
	cmp	byte [esi],':
	jne	load_position_ok
	inc	esi
	cmp	byte [esi],'(
	jne	invalid_argument
	inc	esi
	cmp	byte [esi],'.
	je	invalid_value
	push	ebx
	call	get_dword_value
	pop	ebx
	mov	edx,eax
      load_position_ok:
	xor	al,al
	call	lseek
	mov	dword [value],0
	mov	dword [value+4],0
	movzx	ecx,byte [operand_size]
	mov	edx,value
	call	read
	jc	error_reading_file
	call	close
	mov	eax,dword [value]
	mov	edx,dword [value+4]
	pop	ebx
	xor	ch,ch
	mov	byte [value_type],0
	jmp	make_constant
display_directive:
	push	esi
	push	edi
      prepare_display:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],0
	jne	display_byte
	inc	esi
	lodsd
	mov	ecx,eax
	rep
	movsb
	inc	esi
	jmp	display_next
      display_byte:
	call	get_byte_value
	stosb
      display_next:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	do_display
	cmp	al,0xF
	je	do_display
	cmp	al,',
	jne	extra_characters_on_line
	jmp	prepare_display
      do_display:
	dec	esi
	mov	ebp,edi
	pop	edi
	pop	ebx
	push	esi
	push	edi
	mov	esi,edi
	mov	ecx,ebp
	sub	ecx,esi
	mov	edi,dword [display_buffer]
	sub	edi,ecx
	sub	edi,4
	cmp	edi,esi
	jbe	out_of_memory
	mov	dword [display_buffer],edi
	mov	eax,ecx
	rep
	movsb
	stosd
	pop	edi
	pop	esi
	jmp	instruction_assembled
flush_display_buffer:
	mov	eax,dword [display_buffer]
	or	eax,eax
	jz	display_done
	mov	esi,dword [labels_list]
	cmp	esi,eax
	je	display_done
	mov	word [value],0
      display_messages:
	sub	esi,4
	mov	ecx,[esi]
	mov	ax,word [value]
	jecxz	last_bytes_ok
	mov	al,ah
	mov	ah,[esi-1]
	cmp	ecx,1
	je	last_bytes_ok
	mov	al,[esi-2]
      last_bytes_ok:
	mov	word [value],ax
	sub	esi,ecx
	push	esi
	call	display_block
	pop	esi
	cmp	esi,dword [display_buffer]
	jne	display_messages
	mov	ax,0xA0D
	cmp	word [value],ax
	je	display_ok
	mov	esi,value
	mov	[esi],ax
	mov	ecx,2
	call	display_block
      display_ok:
	mov	eax,dword [labels_list]
	mov	dword [display_buffer],eax
      display_done:
	ret
times_directive:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	or	eax,eax
	jz	zero_times
	cmp	byte [esi],':
	jne	times_argument_ok
	inc	esi
      times_argument_ok:
	push	dword [counter]
	push	dword [counter_limit]
	mov	dword [counter_limit],eax
	mov	dword [counter],1
      times_loop:
	push	esi
	or	byte [times_working],-1
	call	assemble_line
	mov	eax,dword [counter_limit]
	cmp	dword [counter],eax
	je	times_done
	inc	dword [counter]
	pop	esi
	jmp	times_loop
      times_done:
	mov	byte [times_working],0
	pop	eax
	pop	dword [counter_limit]
	pop	dword [counter]
	jmp	instruction_assembled
      zero_times:
	call	skip_line
	jmp	instruction_assembled

virtual_directive:
	lodsb
	cmp	al,0x80
	jne	virtual_at_current
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_address_value
	xor	ch,ch
	or	bh,bh
	jz	set_virtual
	mov	ch,1
	jmp	set_virtual
      virtual_at_current:
	dec	esi
	mov	eax,edi
	sub	eax,dword [org_start]
	xor	bx,bx
	xor	cx,cx
	mov	byte [value_type],0
	cmp	byte [reloc_labels],0
	je	set_virtual
	mov	byte [value_type],2
      set_virtual:
	mov	edx,dword [org_sib]
	mov	byte [org_sib],bh
	mov	byte [org_sib+1],bl
	mov	byte [org_sib+2],ch
	mov	byte [org_sib+3],cl
	call	allocate_structure_data
	mov	word [ebx],virtual_directive-assembler
	neg	eax
	add	eax,edi
	xchg	dword [org_start],eax
	mov	[ebx+4],eax
	mov	[ebx+8],edx
	mov	al,byte [virtual_data]
	mov	[ebx+2],al
	mov	al,byte [reloc_labels]
	mov	[ebx+3],al
	mov	[ebx+0xC],edi
	or	byte [virtual_data],-1
	mov	byte [reloc_labels],0
	cmp	byte [value_type],1
	je	invalid_use_of_symbol
	cmp	byte [value_type],2
	jne	instruction_assembled
	or	byte [reloc_labels],-1
	jmp	instruction_assembled
      allocate_structure_data:
	mov	ebx,dword [structures_buffer]
	sub	ebx,0x10
	cmp	ebx,dword [additional_memory]
	jb	out_of_memory
	mov	dword [structures_buffer],ebx
	ret
      find_structure_data:
	mov	ebx,dword [structures_buffer]
      scan_structures:
	cmp	ebx,dword [additional_memory_end]
	je	no_such_structure
	cmp	ax,[ebx]
	jne	next_structure
	clc
	ret
      next_structure:
	cmp	ax,repeat_directive-assembler
	jne	if_structure_ok
	cmp	word [ebx],if_directive-assembler
	je	no_such_structure
      if_structure_ok:
	cmp	ax,if_directive-assembler
	jne	repeat_structure_ok
	cmp	word [ebx],repeat_directive-assembler
	je	no_such_structure
      repeat_structure_ok:
	add	ebx,0x10
	jmp	scan_structures
      no_such_structure:
	stc
	ret
      end_virtual:
	call	find_structure_data
	jc	unexpected_instruction
	mov	al,[ebx+2]
	mov	byte [virtual_data],al
	mov	al,[ebx+3]
	mov	byte [reloc_labels],al
	mov	eax,[ebx+4]
	mov	dword [org_start],eax
	mov	eax,[ebx+8]
	mov	dword [org_sib],eax
	mov	edi,[ebx+0xC]
      remove_structure_data:
	push	esi
	push	edi
	mov	esi,dword [structures_buffer]
	mov	ecx,ebx
	sub	ecx,esi
	lea	edi,[esi+0x10]
	mov	dword [structures_buffer],edi
	shr	ecx,2
	rep
	movsd
	pop	edi
	pop	esi
	jmp	instruction_assembled
repeat_directive:
	cmp	byte [times_working],0
	jne	unexpected_instruction
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	or	eax,eax
	jz	zero_repeat
	call	allocate_structure_data
	mov	word [ebx],repeat_directive-assembler
	xchg	eax,dword [counter_limit]
	mov	[ebx+4],eax
	mov	eax,1
	xchg	eax,dword [counter]
	mov	[ebx+8],eax
	mov	[ebx+0xC],esi
	jmp	instruction_assembled
      end_repeat:
	cmp	byte [times_working],0
	jne	unexpected_instruction
	call	find_structure_data
	jc	unexpected_instruction
	mov	eax,dword [counter_limit]
	inc	dword [counter]
	cmp	dword [counter],eax
	jbe	continue_repeating
	mov	eax,[ebx+4]
	mov	dword [counter_limit],eax
	mov	eax,[ebx+8]
	mov	dword [counter],eax
	jmp	remove_structure_data
      continue_repeating:
	mov	esi,[ebx+0xC]
	jmp	instruction_assembled
      zero_repeat:
	mov	al,[esi]
	or	al,al
	jz	unexpected_end_of_file
	cmp	al,0xF
	jne	extra_characters_on_line
	call	find_end_repeat
	jmp	instruction_assembled
      find_end_repeat:
	call	find_structure_end
	cmp	ax,repeat_directive-assembler
	jne	unexpected_instruction
	ret
      find_structure_end:
	call	skip_line
	lodsb
	cmp	al,0xF
	jne	unexpected_end_of_file
	lodsd
	mov	dword [current_line],eax
      skip_labels:
	cmp	byte [esi],2
	jne	labels_ok
	add	esi,6
	jmp	skip_labels
      labels_ok:
	cmp	byte [esi],1
	jne	find_structure_end
	mov	ax,[esi+1]
	cmp	ax,prefix_instruction-assembler
	je	find_structure_end
	add	esi,4
	cmp	ax,repeat_directive-assembler
	je	skip_repeat
	cmp	ax,if_directive-assembler
	je	skip_if
	cmp	ax,else_directive-assembler
	je	structure_end
	cmp	ax,end_directive-assembler
	jne	find_structure_end
	cmp	byte [esi],1
	jne	find_structure_end
	mov	ax,[esi+1]
	add	esi,4
	cmp	ax,repeat_directive-assembler
	je	structure_end
	cmp	ax,if_directive-assembler
	jne	find_structure_end
      structure_end:
	ret
      skip_repeat:
	call	find_end_repeat
	jmp	find_structure_end
if_directive:
	cmp	byte [times_working],0
	jne	unexpected_instruction
	call	calculate_logical_expression
	mov	dl,al
	mov	al,[esi]
	or	al,al
	jz	unexpected_end_of_file
	cmp	al,0xF
	jne	extra_characters_on_line
	or	dl,dl
	jnz	if_true
	call	find_else
	jc	instruction_assembled
	mov	al,[esi]
	cmp	al,1
	jne	else_true
	cmp	word [esi+1],if_directive-assembler
	jne	else_true
	add	esi,4
	jmp	if_directive
      if_true:
	call	allocate_structure_data
	mov	word [ebx],if_directive-assembler
	mov	byte [ebx+2],0
	jmp	instruction_assembled
      else_true:
	or	al,al
	jz	unexpected_end_of_file
	cmp	al,0xF
	jne	extra_characters_on_line
	call	allocate_structure_data
	mov	word [ebx],if_directive-assembler
	or	byte [ebx+2],-1
	jmp	instruction_assembled
      else_directive:
	cmp	byte [times_working],0
	jne	unexpected_instruction
	mov	ax,if_directive-assembler
	call	find_structure_data
	jc	unexpected_instruction
	cmp	byte [ebx+2],0
	jne	unexpected_instruction
      found_else:
	mov	al,[esi]
	cmp	al,1
	jne	skip_else
	cmp	word [esi+1],if_directive-assembler
	jne	skip_else
	add	esi,4
	call	find_else
	jnc	found_else
	jmp	remove_structure_data
      skip_else:
	or	al,al
	jz	unexpected_end_of_file
	cmp	al,0xF
	jne	extra_characters_on_line
	call	find_end_if
	jmp	remove_structure_data
      end_if:
	cmp	byte [times_working],0
	jne	unexpected_instruction
	call	find_structure_data
	jc	unexpected_instruction
	jmp	remove_structure_data
      skip_if:
	call	find_else
	jc	find_structure_end
	cmp	byte [esi],1
	jne	skip_after_else
	cmp	word [esi+1],if_directive-assembler
	jne	skip_after_else
	add	esi,4
	jmp	skip_if
      skip_after_else:
	call	find_end_if
	jmp	find_structure_end
      find_else:
	call	find_structure_end
	cmp	ax,else_directive-assembler
	je	else_found
	cmp	ax,if_directive-assembler
	jne	unexpected_instruction
	stc
	ret
      else_found:
	clc
	ret
      find_end_if:
	call	find_structure_end
	cmp	ax,if_directive-assembler
	jne	unexpected_instruction
	ret
end_directive:
	lodsb
	cmp	al,1
	jne	invalid_argument
	lodsw
	inc	esi
	cmp	ax,virtual_directive-assembler
	je	end_virtual
	cmp	ax,repeat_directive-assembler
	je	end_repeat
	cmp	ax,if_directive-assembler
	je	end_if
	jmp	invalid_argument

data_bytes:
	lodsb
	cmp	al,'(
	je	get_byte
	cmp	al,'?
	jne	invalid_argument
	mov	eax,edi
	mov	byte [edi],0
	inc	edi
	call	undefined_data
	jmp	byte_ok
      get_byte:
	cmp	byte [esi],0
	je	get_string
	call	get_byte_value
	stosb
      byte_ok:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	data_end
	cmp	al,0xF
	je	data_end
	cmp	al,',
	jne	extra_characters_on_line
	jmp	data_bytes
      data_end:
	dec	esi
	jmp	instruction_assembled
      get_string:
	inc	esi
	lodsd
	mov	ecx,eax
	rep
	movsb
	inc	esi
	jmp	byte_ok
      undefined_data:
	cmp	byte [virtual_data],0
	je	mark_undefined_data
	ret
      mark_undefined_data:
	cmp	eax,dword [undefined_data_end]
	je	undefined_data_ok
	mov	dword [undefined_data_start],eax
      undefined_data_ok:
	mov	dword [undefined_data_end],edi
	ret
data_unicode:
	or	byte [base_code],-1
	jmp	get_words_data
data_words:
	mov	byte [base_code],0
      get_words_data:
	lodsb
	cmp	al,'(
	je	get_word
	cmp	al,'?
	jne	invalid_argument
	mov	eax,edi
	mov	word [edi],0
	scasw
	call	undefined_data
	jmp	word_ok
      get_word:
	cmp	byte [base_code],0
	je	word_data_value
	cmp	byte [esi],0
	je	word_string
      word_data_value:
	call	get_word_value
	call	mark_relocation
	stosw
      word_ok:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	data_end
	cmp	al,0xF
	je	data_end
	cmp	al,',
	jne	extra_characters_on_line
	jmp	get_words_data
      word_string:
	inc	esi
	lodsd
	mov	ecx,eax
	jecxz	word_string_ok
	xor	ah,ah
      copy_word_string:
	lodsb
	stosw
	loop	copy_word_string
      word_string_ok:
	inc	esi
	jmp	word_ok
data_dwords:
	lodsb
	cmp	al,'(
	je	get_dword
	cmp	al,'?
	jne	invalid_argument
	mov	eax,edi
	mov	dword [edi],0
	scasd
	call	undefined_data
	jmp	dword_ok
      get_dword:
	push	esi
	call	get_dword_value
	pop	ebx
	cmp	byte [esi],':
	je	complex_dword
	call	mark_relocation
	stosd
	jmp	dword_ok
      complex_dword:
	mov	esi,ebx
	cmp	byte [esi],'.
	je	invalid_value
	call	get_word_value
	mov	dx,ax
	inc	esi
	lodsb
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [value_type]
	push	ax
	cmp	byte [esi],'.
	je	invalid_value
	call	get_word_value
	call	mark_relocation
	stosw
	pop	ax
	mov	byte [value_type],al
	mov	ax,dx
	call	mark_relocation
	stosw
      dword_ok:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	data_end
	cmp	al,0xF
	je	data_end
	cmp	al,',
	jne	extra_characters_on_line
	jmp	data_dwords
data_pwords:
	lodsb
	cmp	al,'(
	je	get_pword
	cmp	al,'?
	jne	invalid_argument
	mov	eax,edi
	mov	dword [edi],0
	scasd
	mov	word [edi],0
	scasw
	call	undefined_data
	jmp	pword_ok
      get_pword:
	push	esi
	call	get_pword_value
	pop	ebx
	cmp	byte [esi],':
	je	complex_pword
	call	mark_relocation
	stosd
	mov	ax,dx
	stosw
	jmp	pword_ok
      complex_pword:
	mov	esi,ebx
	cmp	byte [esi],'.
	je	invalid_value
	call	get_word_value
	mov	dx,ax
	inc	esi
	lodsb
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [value_type]
	push	ax
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	call	mark_relocation
	stosd
	pop	ax
	mov	byte [value_type],al
	mov	ax,dx
	call	mark_relocation
	stosw
      pword_ok:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	data_end
	cmp	al,0xF
	je	data_end
	cmp	al,',
	jne	extra_characters_on_line
	jmp	data_pwords
data_qwords:
	lodsb
	cmp	al,'(
	je	get_qword
	cmp	al,'?
	jne	invalid_argument
	mov	eax,edi
	mov	dword [edi],0
	scasd
	mov	dword [edi],0
	scasd
	call	undefined_data
	jmp	qword_ok
      get_qword:
	call	get_qword_value
	call	mark_relocation
	stosd
	mov	eax,edx
	stosd
      qword_ok:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	data_end
	cmp	al,0xF
	je	data_end
	cmp	al,',
	jne	extra_characters_on_line
	jmp	data_qwords
data_twords:
	lodsb
	cmp	al,'(
	je	get_tbyte
	cmp	al,'?
	jne	invalid_argument
	mov	eax,edi
	mov	dword [edi],0
	scasd
	mov	dword [edi],0
	scasd
	mov	word [edi],0
	scasw
	call	undefined_data
	jmp	tbyte_ok
      get_tbyte:
	lodsb
	cmp	al,'.
	jne	invalid_value
	cmp	word [esi+8],0x8000
	je	fp_zero_tbyte
	mov	eax,[esi]
	stosd
	mov	eax,[esi+4]
	stosd
	mov	ax,[esi+8]
	add	ax,0x3FFF
	cmp	ax,0x8000
	jae	value_out_of_range
	mov	bl,[esi+11]
	shl	bx,15
	or	ax,bx
	stosw
	add	esi,12
	jmp	tbyte_ok
      fp_zero_tbyte:
	xor	eax,eax
	stosd
	stosd
	stosw
	add	esi,12
      tbyte_ok:
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	lodsb
	or	al,al
	jz	data_end
	cmp	al,0xF
	je	data_end
	cmp	al,',
	jne	extra_characters_on_line
	jmp	data_twords
data_file:
	lodsw
	cmp	ax,'(
	jne	invalid_argument
	lea	edx,[esi+4]
	mov	eax,[esi]
	lea	esi,[esi+eax+5]
	call	open
	jc	file_not_found
	mov	al,2
	xor	edx,edx
	call	lseek
	push	eax
	xor	edx,edx
	cmp	byte [esi],':
	jne	position_ok
	inc	esi
	cmp	byte [esi],'(
	jne	invalid_argument
	inc	esi
	cmp	byte [esi],'.
	je	invalid_value
	push	ebx
	call	get_dword_value
	pop	ebx
	mov	edx,eax
	sub	[esp],edx
      position_ok:
	cmp	byte [esi],',
	jne	size_ok
	inc	esi
	cmp	byte [esi],'(
	jne	invalid_argument
	inc	esi
	cmp	byte [esi],'.
	je	invalid_value
	push	ebx
	push	edx
	call	get_dword_value
	pop	edx
	pop	ebx
	mov	[esp],eax
      size_ok:
	cmp	byte [next_pass_needed],0
	jne	file_reserve
	xor	al,al
	call	lseek
	pop	ecx
	mov	edx,edi
	add	edi,ecx
	jc	out_of_memory
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	call	read
	jc	error_reading_file
	call	close
      check_for_next_name:
	lodsb
	cmp	al,',
	je	data_file
	dec	esi
	jmp	instruction_assembled
      file_reserve:
	call	close
	pop	ecx
	add	edi,ecx
	jc	out_of_memory
	cmp	edi,dword [display_buffer]
	jae	out_of_memory
	jmp	check_for_next_name
reserve_bytes:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	cmp	eax,0
	jl	reserve_negative
	mov	ecx,eax
	mov	edx,ecx
	add	edx,edi
	jc	out_of_memory
	cmp	edx,dword [display_buffer]
	jae	out_of_memory
	push	edi
	cmp	byte [next_pass_needed],0
	je	zero_bytes
	add	edi,ecx
	jmp	reserved_data
      zero_bytes:
	xor	eax,eax
	shr	ecx,1
	jnc	bytes_stosb_ok
	stosb
      bytes_stosb_ok:
	shr	ecx,1
	jnc	bytes_stosw_ok
	stosw
      bytes_stosw_ok:
	rep
	stosd
      reserved_data:
	pop	eax
	call	undefined_data
	jmp	instruction_assembled
      reserve_negative:
	cmp	dword [error_line],0
	jne	instruction_assembled
	mov	eax,dword [current_line]
	mov	dword [error_line],eax
	mov	dword [error],invalid_value
	jmp	instruction_assembled
reserve_words:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	cmp	eax,0
	jl	reserve_negative
	mov	ecx,eax
	mov	edx,ecx
	shl	edx,1
	jc	out_of_memory
	add	edx,edi
	jc	out_of_memory
	cmp	edx,dword [display_buffer]
	jae	out_of_memory
	push	edi
	cmp	byte [next_pass_needed],0
	je	zero_words
	lea	edi,[edi+ecx*2]
	jmp	reserved_data
      zero_words:
	xor	eax,eax
	shr	ecx,1
	jnc	words_stosw_ok
	stosw
      words_stosw_ok:
	rep
	stosd
	jmp	reserved_data
reserve_dwords:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	cmp	eax,0
	jl	reserve_negative
	mov	ecx,eax
	mov	edx,ecx
	shl	edx,1
	jc	out_of_memory
	shl	edx,1
	jc	out_of_memory
	add	edx,edi
	jc	out_of_memory
	cmp	edx,dword [display_buffer]
	jae	out_of_memory
	push	edi
	cmp	byte [next_pass_needed],0
	je	zero_dwords
	lea	edi,[edi+ecx*4]
	jmp	reserved_data
      zero_dwords:
	xor	eax,eax
	rep
	stosd
	jmp	reserved_data
reserve_pwords:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	cmp	eax,0
	jl	reserve_negative
	mov	ecx,eax
	shl	ecx,1
	jc	out_of_memory
	add	ecx,eax
	mov	edx,ecx
	shl	edx,1
	jc	out_of_memory
	add	edx,edi
	jc	out_of_memory
	cmp	edx,dword [display_buffer]
	jae	out_of_memory
	push	edi
	cmp	byte [next_pass_needed],0
	je	zero_words
	lea	edi,[edi+ecx*2]
	jmp	reserved_data
reserve_qwords:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	cmp	eax,0
	jl	reserve_negative
	mov	ecx,eax
	shl	ecx,1
	jc	out_of_memory
	mov	edx,ecx
	shl	edx,1
	jc	out_of_memory
	shl	edx,1
	jc	out_of_memory
	add	edx,edi
	jc	out_of_memory
	cmp	edx,dword [display_buffer]
	jae	out_of_memory
	push	edi
	cmp	byte [next_pass_needed],0
	je	zero_dwords
	lea	edi,[edi+ecx*4]
	jmp	reserved_data
reserve_twords:
	lodsb
	cmp	al,'(
	jne	invalid_argument
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	cmp	eax,0
	jl	reserve_negative
	mov	ecx,eax
	shl	ecx,2
	jc	out_of_memory
	add	ecx,eax
	mov	edx,ecx
	shl	edx,1
	jc	out_of_memory
	add	edx,edi
	jc	out_of_memory
	cmp	edx,dword [display_buffer]
	jae	out_of_memory
	push	edi
	cmp	byte [next_pass_needed],0
	je	zero_words
	lea	edi,[edi+ecx*2]
	jmp	reserved_data

simple_instruction:
	stosb
	jmp	instruction_assembled
simple_instruction_16bit:
	cmp	byte [code_type],32
	je	size_prefix
	stosb
	jmp	instruction_assembled
      size_prefix:
	mov	ah,al
	mov	al,0x66
	stosw
	jmp	instruction_assembled
simple_instruction_32bit:
	cmp	byte [code_type],16
	je	size_prefix
	stosb
	jmp	instruction_assembled
simple_extended_instruction:
	mov	ah,al
	mov	al,0xF
	stosw
	jmp	instruction_assembled
prefix_instruction:
	stosb
	jmp	assemble_line
int_instruction:
	lodsb
	call	get_size_operator
	cmp	ah,1
	ja	invalid_operand_size
	cmp	al,'(
	jne	invalid_operand
	call	get_byte_value
	mov	ah,al
	mov	al,0xCD
	stosw
	jmp	instruction_assembled
aa_instruction:
	push	ax
	mov	bl,10
	cmp	byte [esi],'(
	jne	store1  ; Not a local label in as86, making it unique.
	inc	esi
	xor	al,al
	xchg	al,byte [operand_size]
	cmp	al,1
	ja	invalid_operand_size
	call	get_byte_value
	mov	bl,al
      store1:
	cmp	byte [operand_size],0
	jne	invalid_operand
	pop	ax
	mov	ah,bl
	stosw
	jmp	instruction_assembled

basic_instruction:
	mov	byte [base_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	basic_reg
	cmp	al,'[
	jne	invalid_operand
      basic_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	cmp	byte [esi],0x11
	sete	al
	mov	byte [imm_sized],al
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	basic_mem_imm
	cmp	al,0x10
	jne	invalid_operand
      basic_mem_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	al,ah
	cmp	al,1
	je	basic_mem_reg_8bit
	cmp	al,2
	je	basic_mem_reg_16bit
	cmp	al,4
	je	basic_mem_reg_32bit
	jmp	invalid_operand_size
      basic_mem_reg_8bit:
	call	store_instruction
	jmp	instruction_assembled
      basic_mem_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      basic_mem_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      basic_mem_imm:
	mov	al,byte [operand_size]
	cmp	al,1
	je	basic_mem_imm_8bit
	cmp	al,2
	je	basic_mem_imm_16bit
	cmp	al,4
	je	basic_mem_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	basic_mem_imm_32bit
      basic_mem_imm_8bit:
	call	get_byte_value
	mov	byte [value],al
	mov	al,byte [base_code]
	shr	al,3
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	byte [base_code],0x80
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      basic_mem_imm_16bit:
	call	get_word_value
	mov	word [value],ax
	mov	al,byte [base_code]
	shr	al,3
	mov	byte [postbyte_register],al
	call	operand_16bit_prefix
	pop	cx
	pop	bx
	pop	edx
	cmp	byte [value_type],0
	jne	store2
	cmp	byte [imm_sized],0
	jne	store2
	cmp	word [value],0x80
	jb	basic_mem_simm_8bit
	cmp	word [value],-0x80
	jae	basic_mem_simm_8bit
      store2:
	mov	byte [base_code],0x81
	call	store_instruction
	mov	ax,word [value]
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      basic_mem_simm_8bit:
	mov	byte [base_code],0x83
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      basic_mem_imm_32bit:
	call	get_dword_value
	mov	dword [value],eax
	mov	al,byte [base_code]
	shr	al,3
	mov	byte [postbyte_register],al
	call	operand_32bit_prefix
	pop	cx
	pop	bx
	pop	edx
	cmp	byte [value_type],0
	jne	store3
	cmp	byte [imm_sized],0
	jne	store3
	cmp	dword [value],0x80
	jb	basic_mem_simm_8bit
	cmp	dword [value],-0x80
	jae	basic_mem_simm_8bit
      store3:
	mov	byte [base_code],0x81
	call	store_instruction
	mov	eax,dword [value]
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      basic_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	cmp	byte [esi],0x11
	sete	al
	mov	byte [imm_sized],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	basic_reg_reg
	cmp	al,'(
	je	basic_reg_imm
	cmp	al,'[
	jne	invalid_operand
      basic_reg_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	basic_reg_mem_8bit
	cmp	al,2
	je	basic_reg_mem_16bit
	cmp	al,4
	je	basic_reg_mem_32bit
	jmp	invalid_operand_size
      basic_reg_mem_8bit:
	add	byte [base_code],2
	call	store_instruction
	jmp	instruction_assembled
      basic_reg_mem_16bit:
	call	operand_16bit_prefix
	add	byte [base_code],3
	call	store_instruction
	jmp	instruction_assembled
      basic_reg_mem_32bit:
	call	operand_32bit_prefix
	add	byte [base_code],3
	call	store_instruction
	jmp	instruction_assembled
      basic_reg_reg:
	lodsb
	call	convert_register
	shl	al,3
	mov	bl,byte [postbyte_register]
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,1
	je	basic_reg_reg_8bit
	cmp	al,2
	je	basic_reg_reg_16bit
	cmp	al,4
	je	basic_reg_reg_32bit
	jmp	invalid_operand_size
      basic_reg_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	jmp	basic_reg_reg_8bit
      basic_reg_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
      basic_reg_reg_8bit:
	mov	al,byte [base_code]
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      basic_reg_imm:
	mov	al,byte [operand_size]
	cmp	al,1
	je	basic_reg_imm_8bit
	cmp	al,2
	je	basic_reg_imm_16bit
	cmp	al,4
	je	basic_reg_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	basic_reg_imm_32bit
      basic_reg_imm_8bit:
	call	get_byte_value
	mov	dl,al
	mov	ah,byte [base_code]
	or	ah,%11000000
	mov	bl,byte [postbyte_register]
	and	bl,%111
	or	bl,bl
	jz	basic_al_imm
	or	ah,bl
	mov	al,0x80
	stosw
	mov	al,dl
	stosb
	jmp	instruction_assembled
      basic_al_imm:
	mov	al,byte [base_code]
	add	al,4
	stosb
	mov	al,dl
	stosb
	jmp	instruction_assembled
      basic_reg_imm_16bit:
	call	get_word_value
	mov	dx,ax
	call	operand_16bit_prefix
	mov	ah,byte [base_code]
	or	ah,%11000000
	mov	bl,byte [postbyte_register]
	and	bl,%111
	or	ah,bl
	cmp	byte [value_type],0
	jne	store4
	cmp	byte [imm_sized],0
	jne	store4
	cmp	dx,0x80
	jb	basic_reg_simm_8bit
	cmp	dx,-0x80
	jae	basic_reg_simm_8bit
      store4:
	or	bl,bl
	jz	basic_ax_imm
	mov	al,0x81
	stosw
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      basic_reg_simm_8bit:
	mov	al,0x83
	stosw
	mov	ax,dx
	stosb
	jmp	instruction_assembled
      basic_ax_imm:
	mov	al,byte [base_code]
	add	al,5
	stosb
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      basic_reg_imm_32bit:
	call	get_dword_value
	mov	edx,eax
	call	operand_32bit_prefix
	mov	ah,byte [base_code]
	or	ah,%11000000
	mov	bl,byte [postbyte_register]
	and	bl,%111
	or	ah,bl
	cmp	byte [value_type],0
	jne	store5
	cmp	byte [imm_sized],0
	jne	store5
	cmp	edx,0x80
	jb	basic_reg_simm_8bit
	cmp	edx,-0x80
	jae	basic_reg_simm_8bit
      store5:
	or	bl,bl
	jz	basic_eax_imm
	mov	al,0x81
	stosw
	mov	eax,edx
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      basic_eax_imm:
	mov	al,byte [base_code]
	add	al,5
	stosb
	mov	eax,edx
	call	mark_relocation
	stosd
	jmp	instruction_assembled
single_operand_instruction:
	mov	byte [base_code],0xF6
	mov	byte [postbyte_register],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	single_reg
	cmp	al,'[
	jne	invalid_operand
      single_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	single_mem_8bit
	cmp	al,2
	je	single_mem_16bit
	cmp	al,4
	je	single_mem_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      single_mem_8bit:
	call	store_instruction
	jmp	instruction_assembled
      single_mem_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      single_mem_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      single_reg:
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	bl,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,1
	je	single_reg_8bit
	cmp	al,2
	je	single_reg_16bit
	cmp	al,4
	je	single_reg_32bit
	jmp	invalid_operand_size
      single_reg_8bit:
	mov	ah,bl
	mov	al,0xF6
	stosw
	jmp	instruction_assembled
      single_reg_16bit:
	call	operand_16bit_prefix
	mov	ah,bl
	mov	al,0xF7
	stosw
	jmp	instruction_assembled
      single_reg_32bit:
	call	operand_32bit_prefix
	mov	ah,bl
	mov	al,0xF7
	stosw
	jmp	instruction_assembled
mov_instruction:
	mov	byte [base_code],0x88
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	mov_reg
	cmp	al,'[
	jne	invalid_operand
      mov_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	mov_mem_imm
	cmp	al,0x10
	jne	invalid_operand
      mov_mem_reg:
	lodsb
	cmp	al,0x60
	jae	mov_mem_sreg
	call	convert_register
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	cmp	ah,1
	je	mov_mem_reg_8bit
	cmp	ah,2
	je	mov_mem_reg_16bit
	cmp	ah,4
	je	mov_mem_reg_32bit
	jmp	invalid_operand_size
      mov_mem_reg_8bit:
	or	al,bl
	or	al,bh
	jz	mov_mem_al
	call	store_instruction
	jmp	instruction_assembled
      mov_mem_al:
	cmp	ch,2
	je	mov_mem_address16_al
	test	ch,4
	jnz	mov_mem_address32_al
	or	ch,ch
	jnz	invalid_address_size
	cmp	byte [code_type],32
	je	mov_mem_address32_al
	cmp	edx,0x10000
	jb	mov_mem_address16_al
      mov_mem_address32_al:
	call	address_32bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA2
      store_mov_address32:
	stosb
	push	dword instruction_assembled
	jmp	store_address_32bit_value
      mov_mem_address16_al:
	call	address_16bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA2
      store_mov_address16:
	stosb
	mov	eax,edx
	stosw
	cmp	edx,0x10000
	jge	value_out_of_range
	jmp	instruction_assembled
      mov_mem_reg_16bit:
	call	operand_16bit_prefix
	mov	al,byte [postbyte_register]
	or	al,bl
	or	al,bh
	jz	mov_mem_ax
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      mov_mem_ax:
	cmp	ch,2
	je	mov_mem_address16_ax
	test	ch,4
	jnz	mov_mem_address32_ax
	or	ch,ch
	jnz	invalid_address_size
	cmp	byte [code_type],32
	je	mov_mem_address32_ax
	cmp	edx,0x10000
	jb	mov_mem_address16_ax
      mov_mem_address32_ax:
	call	address_32bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA3
	jmp	store_mov_address32
      mov_mem_address16_ax:
	call	address_16bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA3
	jmp	store_mov_address16
      mov_mem_reg_32bit:
	call	operand_32bit_prefix
	mov	al,byte [postbyte_register]
	or	al,bl
	or	al,bh
	jz	mov_mem_ax
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      mov_mem_sreg:
	cmp	al,0x70
	jae	invalid_operand
	sub	al,0x61
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	ah,byte [operand_size]
	or	ah,ah
	jz	mov_mem_sreg_size_ok
	cmp	ah,2
	je	mov_mem16_sreg
	cmp	ah,4
	je	mov_mem32_sreg
	jmp	invalid_operand_size
      mov_mem32_sreg:
	call	operand_32bit_prefix
	jmp	mov_mem_sreg_size_ok
      mov_mem16_sreg:
	call	operand_16bit_prefix
      mov_mem_sreg_size_ok:
	mov	byte [base_code],0x8C
	call	store_instruction
	jmp	instruction_assembled
      mov_mem_imm:
	mov	al,byte [operand_size]
	cmp	al,1
	je	mov_mem_imm_8bit
	cmp	al,2
	je	mov_mem_imm_16bit
	cmp	al,4
	je	mov_mem_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	mov_mem_imm_32bit
      mov_mem_imm_8bit:
	call	get_byte_value
	mov	byte [value],al
	mov	byte [postbyte_register],0
	mov	byte [base_code],0xC6
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      mov_mem_imm_16bit:
	call	get_word_value
	mov	word [value],ax
	mov	byte [postbyte_register],0
	mov	byte [base_code],0xC7
	call	operand_16bit_prefix
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	ax,word [value]
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      mov_mem_imm_32bit:
	call	get_dword_value
	mov	dword [value],eax
	mov	byte [postbyte_register],0
	mov	byte [base_code],0xC7
	call	operand_32bit_prefix
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	eax,dword [value]
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      mov_reg:
	lodsb
	cmp	al,0x50
	jae	mov_sreg
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'[
	je	mov_reg_mem
	cmp	al,'(
	je	mov_reg_imm
	cmp	al,0x10
	jne	invalid_operand
      mov_reg_reg:
	lodsb
	cmp	al,0x50
	jae	mov_reg_sreg
	call	convert_register
	shl	al,3
	mov	bl,byte [postbyte_register]
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,1
	je	mov_reg_reg_8bit
	cmp	al,2
	je	mov_reg_reg_16bit
	cmp	al,4
	je	mov_reg_reg_32bit
	jmp	invalid_operand_size
      mov_reg_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	jmp	mov_reg_reg_8bit
      mov_reg_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
      mov_reg_reg_8bit:
	mov	al,byte [base_code]
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      mov_reg_sreg:
	mov	ah,al
	shr	ah,4
	cmp	ah,5
	je	mov_reg_creg
	cmp	ah,7
	je	mov_reg_dreg
	ja	invalid_operand
	sub	al,0x61
	mov	bl,byte [postbyte_register]
	shl	al,3
	or	bl,al
	or	bl,%11000000
	cmp	byte [operand_size],4
	je	mov_reg_sreg32
	cmp	byte [operand_size],2
	jne	invalid_operand_size
	call	operand_16bit_prefix
	jmp	mov_reg_sreg_store
     mov_reg_sreg32:
	call	operand_32bit_prefix
     mov_reg_sreg_store:
	mov	al,0x8C
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      mov_reg_creg:
	mov	bh,0x20
	jmp	mov_reg_xrx
      mov_reg_dreg:
	mov	bh,0x21
      mov_reg_xrx:
	and	al,%111
	mov	bl,byte [postbyte_register]
	shl	al,3
	or	bl,al
	or	bl,%11000000
	cmp	byte [operand_size],4
	jne	invalid_operand_size
	mov	ah,bh
	mov	al,0xF
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
      mov_reg_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	mov_reg_mem_8bit
	cmp	al,2
	je	mov_reg_mem_16bit
	cmp	al,4
	je	mov_reg_mem_32bit
	jmp	invalid_operand_size
      mov_reg_mem_8bit:
	mov	al,byte [postbyte_register]
	or	al,bl
	or	al,bh
	jz	mov_al_mem
	add	byte [base_code],2
	call	store_instruction
	jmp	instruction_assembled
      mov_al_mem:
	cmp	ch,2
	je	mov_al_mem_address16
	test	ch,4
	jnz	mov_al_mem_address32
	or	ch,ch
	jnz	invalid_address_size
	cmp	byte [code_type],32
	je	mov_al_mem_address32
	cmp	edx,0x10000
	jb	mov_al_mem_address16
      mov_al_mem_address32:
	call	address_32bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA0
	jmp	store_mov_address32
      mov_al_mem_address16:
	call	address_16bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA0
	jmp	store_mov_address16
      mov_reg_mem_16bit:
	call	operand_16bit_prefix
	mov	al,byte [postbyte_register]
	or	al,bl
	or	al,bh
	jz	mov_ax_mem
	add	byte [base_code],3
	call	store_instruction
	jmp	instruction_assembled
      mov_ax_mem:
	cmp	ch,2
	je	mov_ax_mem_address16
	test	ch,4
	jnz	mov_ax_mem_address32
	or	ch,ch
	jnz	invalid_address_size
	cmp	byte [code_type],32
	je	mov_ax_mem_address32
	cmp	edx,0x10000
	jb	mov_ax_mem_address16
      mov_ax_mem_address32:
	call	address_32bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA1
	jmp	store_mov_address32
      mov_ax_mem_address16:
	call	address_16bit_prefix
	call	store_segment_prefix_if_necessary
	mov	al,0xA1
	jmp	store_mov_address16
      mov_reg_mem_32bit:
	call	operand_32bit_prefix
	mov	al,byte [postbyte_register]
	or	al,bl
	or	al,bh
	jz	mov_ax_mem
	add	byte [base_code],3
	call	store_instruction
	jmp	instruction_assembled
      mov_reg_imm:
	mov	al,byte [operand_size]
	cmp	al,1
	je	mov_reg_imm_8bit
	cmp	al,2
	je	mov_reg_imm_16bit
	cmp	al,4
	je	mov_reg_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	mov_reg_imm_32bit
      mov_reg_imm_8bit:
	call	get_byte_value
	mov	ah,al
	mov	al,byte [postbyte_register]
	and	al,%111
	add	al,0xB0
	stosw
	jmp	instruction_assembled
      mov_reg_imm_16bit:
	call	get_word_value
	mov	dx,ax
	call	operand_16bit_prefix
	mov	al,byte [postbyte_register]
	and	al,%111
	add	al,0xB8
	stosb
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      mov_reg_imm_32bit:
	call	get_dword_value
	mov	edx,eax
	call	operand_32bit_prefix
	mov	al,byte [postbyte_register]
	and	al,%111
	add	al,0xB8
	stosb
	mov	eax,edx
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      mov_sreg:
	mov	ah,al
	shr	ah,4
	cmp	ah,5
	je	mov_creg
	cmp	ah,7
	je	mov_dreg
	ja	invalid_operand
	sub	al,0x61
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'[
	je	mov_sreg_mem
	cmp	al,0x10
	jne	invalid_operand
      mov_sreg_reg:
	lodsb
	call	convert_register
	or	ah,ah
	jz	mov_sreg_reg_size_ok
	cmp	ah,4
	je	mov_sreg_reg32
	cmp	ah,2
	je	mov_sreg_reg16
	jmp	invalid_operand_size
      mov_sreg_reg32:
	mov	ah,al
	call	operand_32bit_prefix
	mov	al,ah
	jmp	mov_sreg_reg_size_ok
      mov_sreg_reg16:
	mov	ah,al
	call	operand_16bit_prefix
	mov	al,ah
      mov_sreg_reg_size_ok:
	mov	bl,%11000000
	or	bl,al
	mov	al,byte [postbyte_register]
	shl	al,3
	or	bl,al
	mov	al,0x8E
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      mov_sreg_mem:
	call	get_address
	mov	al,byte [operand_size]
	or	al,al
	jz	mov_sreg_mem_size_ok
	cmp	al,2
	je	mov_sreg_mem16
	cmp	al,4
	je	mov_sreg_mem32
	jmp	invalid_operand_size
      mov_sreg_mem32:
	call	operand_32bit_prefix
	jmp	mov_sreg_mem_size_ok
      mov_sreg_mem16:
	call	operand_16bit_prefix
      mov_sreg_mem_size_ok:
	mov	byte [base_code],0x8E
	call	store_instruction
	jmp	instruction_assembled
      mov_creg:
	mov	dl,0x22
	jmp	mov_xrx
      mov_dreg:
	mov	dl,0x23
      mov_xrx:
	and	al,%111
	mov	bh,al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	cmp	ah,4
	jne	invalid_operand_size
	mov	bl,%11000000
	or	bl,al
	mov	al,bh
	shl	al,3
	or	bl,al
	mov	al,0xF
	mov	ah,dl
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
test_instruction:
	mov	byte [base_code],0x84
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	test_reg
	cmp	al,'[
	jne	invalid_operand
      test_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	test_mem_imm
	cmp	al,0x10
	jne	invalid_operand
      test_mem_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	al,ah
	cmp	al,1
	je	test_mem_reg_8bit
	cmp	al,2
	je	test_mem_reg_16bit
	cmp	al,4
	je	test_mem_reg_32bit
	jmp	invalid_operand_size
      test_mem_reg_8bit:
	call	store_instruction
	jmp	instruction_assembled
      test_mem_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      test_mem_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      test_mem_imm:
	mov	al,byte [operand_size]
	cmp	al,1
	je	test_mem_imm_8bit
	cmp	al,2
	je	test_mem_imm_16bit
	cmp	al,4
	je	test_mem_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	test_mem_imm_32bit
      test_mem_imm_8bit:
	call	get_byte_value
	mov	byte [value],al
	mov	byte [postbyte_register],0
	mov	byte [base_code],0xF6
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      test_mem_imm_16bit:
	call	get_word_value
	mov	word [value],ax
	mov	byte [postbyte_register],0
	mov	byte [base_code],0xF7
	call	operand_16bit_prefix
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	ax,word [value]
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      test_mem_imm_32bit:
	call	get_dword_value
	mov	dword [value],eax
	mov	byte [postbyte_register],0
	mov	byte [base_code],0xF7
	call	operand_32bit_prefix
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	eax,dword [value]
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      test_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	test_reg_imm
	cmp	al,0x10
	jne	invalid_operand
      test_reg_reg:
	lodsb
	call	convert_register
	shl	al,3
	mov	bl,byte [postbyte_register]
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,1
	je	test_reg_reg_8bit
	cmp	al,2
	je	test_reg_reg_16bit
	cmp	al,4
	je	test_reg_reg_32bit
	jmp	invalid_operand_size
      test_reg_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	jmp	basic_reg_reg_8bit
      test_reg_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
      test_reg_reg_8bit:
	mov	al,byte [base_code]
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      test_reg_imm:
	mov	al,byte [operand_size]
	cmp	al,1
	je	test_reg_imm_8bit
	cmp	al,2
	je	test_reg_imm_16bit
	cmp	al,4
	je	test_reg_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	test_reg_imm_32bit
      test_reg_imm_8bit:
	call	get_byte_value
	mov	dl,al
	mov	ah,%11000000
	mov	bl,byte [postbyte_register]
	and	bl,%111
	or	bl,bl
	jz	test_al_imm
	or	ah,bl
	mov	al,0xF6
	stosw
	mov	al,dl
	stosb
	jmp	instruction_assembled
      test_al_imm:
	mov	al,0xA8
	stosb
	mov	al,dl
	stosb
	jmp	instruction_assembled
      test_reg_imm_16bit:
	call	get_word_value
	mov	dx,ax
	call	operand_16bit_prefix
	mov	ah,%11000000
	mov	bl,byte [postbyte_register]
	and	bl,%111
	or	bl,bl
	jz	test_ax_imm
	or	ah,bl
	mov	al,0xF7
	stosw
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      test_ax_imm:
	mov	al,0xA9
	stosb
	mov	ax,dx
	stosw
	jmp	instruction_assembled
      test_reg_imm_32bit:
	call	get_dword_value
	mov	edx,eax
	call	operand_32bit_prefix
	mov	ah,%11000000
	mov	bl,byte [postbyte_register]
	and	bl,%111
	or	bl,bl
	jz	test_eax_imm
	or	ah,bl
	mov	al,0xF7
	stosw
	mov	eax,edx
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      test_eax_imm:
	mov	al,0xA9
	stosb
	mov	eax,edx
	stosd
	jmp	instruction_assembled
xchg_instruction:
	mov	byte [base_code],0x86
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	xchg_reg
	cmp	al,'[
	jne	invalid_operand
      xchg_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
      xchg_mem_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	al,ah
	cmp	al,1
	je	xchg_mem_reg_8bit
	cmp	al,2
	je	xchg_mem_reg_16bit
	cmp	al,4
	je	xchg_mem_reg_32bit
	jmp	invalid_operand_size
      xchg_mem_reg_8bit:
	call	store_instruction
	jmp	instruction_assembled
      xchg_mem_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      xchg_mem_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      xchg_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'[
	je	xchg_reg_mem
	cmp	al,0x10
	jne	invalid_operand
      xchg_reg_reg:
	lodsb
	call	convert_register
	mov	bh,al
	mov	bl,byte [postbyte_register]
	shl	byte [postbyte_register],3
	or	al,%11000000
	or	byte [postbyte_register],al
	mov	al,ah
	cmp	al,1
	je	xchg_reg_reg_8bit
	cmp	al,2
	je	xchg_reg_reg_16bit
	cmp	al,4
	je	xchg_reg_reg_32bit
	jmp	invalid_operand_size
      xchg_reg_reg_32bit:
	call	operand_32bit_prefix
	or	bh,bh
	jz	xchg_ax_reg
	xchg	bh,bl
	or	bh,bh
	jz	xchg_ax_reg
	inc	byte [base_code]
	jmp	xchg_reg_reg_8bit
      xchg_reg_reg_16bit:
	call	operand_16bit_prefix
	or	bh,bh
	jz	xchg_ax_reg
	xchg	bh,bl
	or	bh,bh
	jz	xchg_ax_reg
	inc	byte [base_code]
      xchg_reg_reg_8bit:
	mov	al,byte [base_code]
	mov	ah,byte [postbyte_register]
	stosw
	jmp	instruction_assembled
      xchg_ax_reg:
	mov	al,0x90
	add	al,bl
	stosb
	jmp	instruction_assembled
      xchg_reg_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	xchg_reg_mem_8bit
	cmp	al,2
	je	xchg_reg_mem_16bit
	cmp	al,4
	je	xchg_reg_mem_32bit
	jmp	invalid_operand_size
      xchg_reg_mem_8bit:
	call	store_instruction
	jmp	instruction_assembled
      xchg_reg_mem_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      xchg_reg_mem_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
push_instruction:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	push_reg
	cmp	al,'(
	je	push_imm
	cmp	al,'[
	jne	invalid_operand
      push_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,2
	je	push_mem_16bit
	cmp	al,4
	je	push_mem_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      push_mem_16bit:
	call	operand_16bit_prefix
	mov	byte [base_code],0xFF
	mov	byte [postbyte_register],%110
	call	store_instruction
	jmp	push_done
      push_mem_32bit:
	call	operand_32bit_prefix
	mov	byte [base_code],0xFF
	mov	byte [postbyte_register],%110
	call	store_instruction
	jmp	push_done
      push_reg:
	lodsb
	cmp	al,0x60
	jae	push_sreg
	call	convert_register
	mov	dl,al
	add	dl,0x50
	mov	al,ah
	cmp	al,2
	je	push_reg_16bit
	cmp	al,4
	je	push_reg_32bit
	jmp	invalid_operand_size
      push_reg_16bit:
	call	operand_16bit_prefix
	mov	al,dl
	stosb
	jmp	push_done
      push_reg_32bit:
	call	operand_32bit_prefix
	mov	al,dl
	stosb
	jmp	push_done
      push_sreg:
	mov	bl,byte [operand_size]
	cmp	bl,4
	je	push_sreg32
	cmp	bl,2
	je	push_sreg16
	or	bl,bl
	jz	push_sreg_store
	jmp	invalid_operand_size
      push_sreg16:
	mov	bl,al
	call	operand_16bit_prefix
	mov	al,bl
	jmp	push_sreg_store
      push_sreg32:
	mov	bl,al
	call	operand_32bit_prefix
	mov	al,bl
      push_sreg_store:
	cmp	al,0x70
	jae	invalid_operand
	sub	al,0x61
	cmp	al,4
	jae	push_sreg_386
	shl	al,3
	add	al,6
	stosb
	jmp	push_done
      push_sreg_386:
	sub	al,4
	shl	al,3
	mov	ah,0xA0
	add	ah,al
	mov	al,0xF
	stosw
	jmp	push_done
      push_imm:
	mov	al,byte [operand_size]
	cmp	al,2
	je	push_imm_16bit
	cmp	al,4
	je	push_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [code_type],16
	je	push_imm_optimized_16bit
      push_imm_optimized_32bit:
	call	get_dword_value
	mov	edx,eax
	cmp	byte [value_type],0
	jne	push_imm_32bit_forced
	cmp	eax,-0x80
	jl	push_imm_32bit_forced
	cmp	eax,0x80
	jge	push_imm_32bit_forced
      push_imm_8bit:
	mov	ah,al
	mov	al,0x6A
	stosw
	jmp	push_done
      push_imm_optimized_16bit:
	call	get_word_value
	mov	dx,ax
	cmp	byte [value_type],0
	jne	push_imm_16bit_forced
	cmp	ax,-0x80
	jl	push_imm_16bit_forced
	cmp	ax,0x80
	jge	push_imm_16bit_forced
	jmp	push_imm_8bit
      push_imm_16bit:
	call	get_word_value
	mov	dx,ax
	call	operand_16bit_prefix
      push_imm_16bit_forced:
	mov	al,0x68
	stosb
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	push_done
      push_imm_32bit:
	call	get_dword_value
	mov	edx,eax
	call	operand_32bit_prefix
      push_imm_32bit_forced:
	mov	al,0x68
	stosb
	mov	eax,edx
	call	mark_relocation
	stosd
      push_done:
	lodsb
	dec	esi
	cmp	al,0xF
	je	instruction_assembled
	or	al,al
	jz	instruction_assembled
	mov	byte [operand_size],0
	mov	byte [forced_size],0
	jmp	push_instruction
pop_instruction:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	pop_reg
	cmp	al,'[
	jne	invalid_operand
      pop_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,2
	je	pop_mem_16bit
	cmp	al,4
	je	pop_mem_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      pop_mem_16bit:
	call	operand_16bit_prefix
	mov	byte [base_code],0x8F
	mov	byte [postbyte_register],0
	call	store_instruction
	jmp	pop_done
      pop_mem_32bit:
	call	operand_32bit_prefix
	mov	byte [base_code],0x8F
	mov	byte [postbyte_register],0
	call	store_instruction
	jmp	pop_done
      pop_reg:
	lodsb
	cmp	al,0x60
	jae	pop_sreg
	call	convert_register
	mov	dl,al
	add	dl,0x58
	mov	al,ah
	cmp	al,2
	je	pop_reg_16bit
	cmp	al,4
	je	pop_reg_32bit
	jmp	invalid_operand_size
      pop_reg_16bit:
	call	operand_16bit_prefix
	mov	al,dl
	stosb
	jmp	pop_done
      pop_reg_32bit:
	call	operand_32bit_prefix
	mov	al,dl
	stosb
	jmp	pop_done
      pop_sreg:
	mov	bl,byte [operand_size]
	cmp	bl,4
	je	pop_sreg32
	cmp	bl,2
	je	pop_sreg16
	or	bl,bl
	jz	pop_sreg_store
	jmp	invalid_operand_size
      pop_sreg16:
	mov	bl,al
	call	operand_16bit_prefix
	mov	al,bl
	jmp	pop_sreg_store
      pop_sreg32:
	mov	bl,al
	call	operand_32bit_prefix
	mov	al,bl
      pop_sreg_store:
	cmp	al,0x70
	jae	invalid_operand
	sub	al,0x61
	cmp	al,1
	je	illegal_instruction
	cmp	al,4
	jae	pop_sreg_386
	shl	al,3
	add	al,7
	stosb
	jmp	pop_done
      pop_sreg_386:
	sub	al,4
	shl	al,3
	mov	ah,0xA1
	add	ah,al
	mov	al,0xF
	stosw
      pop_done:
	lodsb
	dec	esi
	cmp	al,0xF
	je	instruction_assembled
	or	al,al
	jz	instruction_assembled
	mov	byte [operand_size],0
	mov	byte [forced_size],0
	jmp	pop_instruction
inc_instruction:
	mov	byte [base_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	inc_reg
	cmp	al,'[
	je	inc_mem
	jne	invalid_operand
      inc_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	inc_mem_8bit
	cmp	al,2
	je	inc_mem_16bit
	cmp	al,4
	je	inc_mem_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      inc_mem_8bit:
	mov	al,0xFE
	xchg	al,byte [base_code]
	mov	byte [postbyte_register],al
	call	store_instruction
	jmp	instruction_assembled
      inc_mem_16bit:
	call	operand_16bit_prefix
	mov	al,0xFF
	xchg	al,byte [base_code]
	mov	byte [postbyte_register],al
	call	store_instruction
	jmp	instruction_assembled
      inc_mem_32bit:
	call	operand_32bit_prefix
	mov	al,0xFF
	xchg	al,byte [base_code]
	mov	byte [postbyte_register],al
	call	store_instruction
	jmp	instruction_assembled
      inc_reg:
	lodsb
	call	convert_register
	mov	dl,al
	shr	al,4
	mov	al,ah
	cmp	al,1
	je	inc_reg_8bit
	mov	dh,byte [base_code]
	shl	dh,3
	add	dl,dh
	add	dl,0x40
	cmp	al,2
	je	inc_reg_16bit
	cmp	al,4
	je	inc_reg_32bit
	jmp	invalid_operand_size
      inc_reg_8bit:
	mov	al,0xFE
	mov	ah,byte [base_code]
	shl	ah,3
	or	ah,dl
	or	ah,%11000000
	stosw
	jmp	instruction_assembled
      inc_reg_16bit:
	call	operand_16bit_prefix
	mov	al,dl
	stosb
	jmp	instruction_assembled
      inc_reg_32bit:
	call	operand_32bit_prefix
	mov	al,dl
	stosb
	jmp	instruction_assembled
arpl_instruction:
	mov	byte [base_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	arpl_reg
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	cmp	ah,2
	jne	invalid_operand_size
	mov	byte [base_code],0x63
	call	store_instruction
	jmp	instruction_assembled
      arpl_reg:
	lodsb
	call	convert_register
	cmp	ah,2
	jne	invalid_operand_size
	mov	dl,al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	cmp	ah,2
	jne	invalid_operand_size
	mov	ah,al
	shl	ah,3
	or	ah,dl
	or	ah,%11000000
	mov	al,0x63
	stosw
	jmp	instruction_assembled
bound_instruction:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,2
	je	bound_16bit
	cmp	al,4
	je	bound_32bit
	jmp	invalid_operand_size
      bound_32bit:
	call	operand_32bit_prefix
	mov	byte [base_code],0x62
	call	store_instruction
	jmp	instruction_assembled
      bound_16bit:
	call	operand_16bit_prefix
	mov	byte [base_code],0x62
	call	store_instruction
	jmp	instruction_assembled
set_instruction:
	mov	byte [base_code],0xF
	mov	byte [extended_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	set_reg
	cmp	al,'[
	jne	invalid_operand
      set_mem:
	call	get_address
	cmp	byte [operand_size],1
	ja	invalid_operand_size
	mov	byte [postbyte_register],0
	call	store_instruction
	jmp	instruction_assembled
      set_reg:
	lodsb
	call	convert_register
	mov	bl,al
	cmp	ah,1
	jne	invalid_operand_size
	mov	ah,byte [extended_code]
	mov	al,0xF
	stosw
	mov	al,%11000000
	or	al,bl
	stosb
	jmp	instruction_assembled
ret_instruction_16bit:
	mov	ah,al
	call	operand_16bit_prefix
	mov	al,ah
	jmp	ret_instruction
ret_instruction_32bit:
	mov	ah,al
	call	operand_32bit_prefix
	mov	al,ah
ret_instruction:
	mov	byte [base_code],al
	lodsb
	dec	esi
	or	al,al
	jz	simple_ret
	cmp	al,0xF
	je	simple_ret
	lodsb
	call	get_size_operator
	or	ah,ah
	jz	ret_imm
	cmp	ah,2
	je	ret_imm
	jmp	invalid_operand_size
      ret_imm:
	cmp	al,'(
	jne	invalid_operand
	call	get_word_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	mov	dx,ax
	mov	al,byte [base_code]
	stosb
	mov	ax,dx
	stosw
	jmp	instruction_assembled
      simple_ret:
	mov	al,byte [base_code]
	inc	al
	stosb
	jmp	instruction_assembled
lea_instruction:
	mov	byte [base_code],0x8D
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	al,byte [operand_size]
	push	ax
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	pop	ax
	cmp	al,2
	je	lea_16bit
	cmp	al,4
	je	lea_32bit
	jmp	invalid_operand_size
      lea_16bit:
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      lea_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
ls_instruction:
	or	al,al
	jz	les_instruction
	cmp	al,3
	jz	lds_instruction
	add	al,0xB0
	mov	byte [extended_code],al
	mov	byte [base_code],0xF
	jmp	ls_code_ok
      les_instruction:
	mov	byte [base_code],0xC4
	jmp	ls_code_ok
      lds_instruction:
	mov	byte [base_code],0xC5
      ls_code_ok:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	add	byte [operand_size],2
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,4
	je	ls_16bit
	cmp	al,6
	je	ls_32bit
	jmp	invalid_operand_size
      ls_16bit:
	call	operand_16bit_prefix
	call	store_instruction
	cmp	byte [operand_size],0
	je	instruction_assembled
	cmp	byte [operand_size],4
	jne	invalid_operand_size
	jmp	instruction_assembled
      ls_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	cmp	byte [operand_size],0
	je	instruction_assembled
	cmp	byte [operand_size],6
	jne	invalid_operand_size
	jmp	instruction_assembled
enter_instruction:
	lodsb
	call	get_size_operator
	cmp	ah,2
	je	enter_imm16_size_ok
	or	ah,ah
	jnz	invalid_operand_size
      enter_imm16_size_ok:
	cmp	al,'(
	jne	invalid_operand
	call	get_word_value
	cmp	byte [value_type],0
	jne	invalid_use_of_symbol
	push	ax
	mov	byte [operand_size],0
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	ah,1
	je	enter_imm8_size_ok
	or	ah,ah
	jnz	invalid_operand_size
      enter_imm8_size_ok:
	cmp	al,'(
	jne	invalid_operand
	call	get_byte_value
	mov	dl,al
	pop	bx
	mov	al,0xC8
	stosb
	mov	ax,bx
	stosw
	mov	al,dl
	stosb
	jmp	instruction_assembled
sh_instruction:
	mov	byte [postbyte_register],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	sh_reg
	cmp	al,'[
	jne	invalid_operand
      sh_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	mov	al,byte [operand_size]
	push	ax
	mov	byte [operand_size],0
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	sh_mem_imm
	cmp	al,0x10
	jne	invalid_operand
      sh_mem_reg:
	lodsb
	cmp	al,0x11
	jne	invalid_operand
	pop	ax
	pop	cx
	pop	bx
	pop	edx
	cmp	al,1
	je	sh_mem_cl_8bit
	cmp	al,2
	je	sh_mem_cl_16bit
	cmp	al,4
	je	sh_mem_cl_32bit
	or	ah,ah
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      sh_mem_cl_8bit:
	mov	byte [base_code],0xD2
	call	store_instruction
	jmp	instruction_assembled
      sh_mem_cl_16bit:
	mov	byte [base_code],0xD3
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      sh_mem_cl_32bit:
	mov	byte [base_code],0xD3
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      sh_mem_imm:
	mov	al,byte [operand_size]
	or	al,al
	jz	sh_mem_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      sh_mem_imm_size_ok:
	call	get_byte_value
	mov	byte [value],al
	pop	ax
	pop	cx
	pop	bx
	pop	edx
	cmp	al,1
	je	sh_mem_imm_8bit
	cmp	al,2
	je	sh_mem_imm_16bit
	cmp	al,4
	je	sh_mem_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      sh_mem_imm_8bit:
	cmp	byte [value],1
	je	sh_mem_1_8bit
	mov	byte [base_code],0xC0
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      sh_mem_1_8bit:
	mov	byte [base_code],0xD0
	call	store_instruction
	jmp	instruction_assembled
      sh_mem_imm_16bit:
	cmp	byte [value],1
	je	sh_mem_1_16bit
	mov	byte [base_code],0xC1
	call	operand_16bit_prefix
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      sh_mem_1_16bit:
	mov	byte [base_code],0xD1
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      sh_mem_imm_32bit:
	cmp	byte [value],1
	je	sh_mem_1_32bit
	mov	byte [base_code],0xC1
	call	operand_32bit_prefix
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      sh_mem_1_32bit:
	mov	byte [base_code],0xD1
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      sh_reg:
	lodsb
	call	convert_register
	shl	byte [postbyte_register],3
	or	al,%11000000
	or	byte [postbyte_register],al
	mov	al,ah
	push	ax
	mov	byte [operand_size],0
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	sh_reg_imm
	cmp	al,0x10
	jne	invalid_operand
      sh_reg_reg:
	lodsb
	cmp	al,0x11
	jne	invalid_operand
	pop	ax
	mov	bl,byte [postbyte_register]
	cmp	al,1
	je	sh_reg_cl_8bit
	cmp	al,2
	je	sh_reg_cl_16bit
	cmp	al,4
	je	sh_reg_cl_32bit
	jmp	invalid_operand_size
      sh_reg_cl_8bit:
	mov	al,0xD2
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      sh_reg_cl_16bit:
	call	operand_16bit_prefix
	mov	al,0xD3
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      sh_reg_cl_32bit:
	call	operand_32bit_prefix
	mov	al,0xD3
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      sh_reg_imm:
	mov	al,byte [operand_size]
	or	al,al
	jz	sh_reg_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      sh_reg_imm_size_ok:
	call	get_byte_value
	mov	byte [value],al
	pop	ax
	mov	bl,byte [postbyte_register]
	cmp	al,1
	je	sh_reg_imm_8bit
	cmp	al,2
	je	sh_reg_imm_16bit
	cmp	al,4
	je	sh_reg_imm_32bit
	jmp	invalid_operand_size
      sh_reg_imm_8bit:
	cmp	byte [value],1
	je	sh_reg_1_8bit
	mov	al,0xC0
	stosb
	mov	al,bl
	mov	ah,byte [value]
	stosw
	jmp	instruction_assembled
      sh_reg_1_8bit:
	mov	al,0xD0
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      sh_reg_imm_16bit:
	cmp	byte [value],1
	je	sh_reg_1_16bit
	call	operand_16bit_prefix
	mov	al,0xC1
	stosb
	mov	al,bl
	mov	ah,byte [value]
	stosw
	jmp	instruction_assembled
      sh_reg_1_16bit:
	call	operand_16bit_prefix
	mov	al,0xD1
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      sh_reg_imm_32bit:
	cmp	byte [value],1
	je	sh_reg_1_32bit
	call	operand_32bit_prefix
	mov	al,0xC1
	stosb
	mov	al,bl
	mov	ah,byte [value]
	stosw
	jmp	instruction_assembled
      sh_reg_1_32bit:
	call	operand_32bit_prefix
	mov	al,0xD1
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
shd_instruction:
	mov	byte [base_code],0xF
	mov	byte [extended_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	shd_reg
	cmp	al,'[
	jne	invalid_operand
      shd_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	xor	al,al
	xchg	al,byte [operand_size]
	push	ax
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	shd_mem_reg_imm
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	cmp	al,0x11
	jne	invalid_operand
	pop	ax
	pop	cx
	pop	bx
	pop	edx
	cmp	al,2
	je	shd_mem_reg_cl_16bit
	cmp	al,4
	je	shd_mem_reg_cl_32bit
	jmp	invalid_operand_size
      shd_mem_reg_cl_16bit:
	call	operand_16bit_prefix
	inc	byte [extended_code]
	call	store_instruction
	jmp	instruction_assembled
      shd_mem_reg_cl_32bit:
	call	operand_32bit_prefix
	inc	byte [extended_code]
	call	store_instruction
	jmp	instruction_assembled
      shd_mem_reg_imm:
	mov	al,byte [operand_size]
	or	al,al
	jz	shd_mem_reg_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      shd_mem_reg_imm_size_ok:
	call	get_byte_value
	mov	byte [value],al
	pop	ax
	pop	cx
	pop	bx
	pop	edx
	cmp	al,2
	je	shd_mem_reg_imm_16bit
	cmp	al,4
	je	shd_mem_reg_imm_32bit
	jmp	invalid_operand_size
      shd_mem_reg_imm_16bit:
	call	operand_16bit_prefix
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      shd_mem_reg_imm_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      shd_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	al,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	push	ax
	push	bx
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	shd_reg_reg_imm
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	cmp	al,0x11
	jne	invalid_operand
	pop	bx
	pop	ax
	cmp	al,2
	je	shd_reg_reg_cl_16bit
	cmp	al,4
	je	shd_reg_reg_cl_32bit
	jmp	invalid_operand_size
      shd_reg_reg_cl_16bit:
	call	operand_16bit_prefix
	jmp	shd_reg_reg_cl_store
      shd_reg_reg_cl_32bit:
	call	operand_32bit_prefix
      shd_reg_reg_cl_store:
	mov	ah,byte [extended_code]
	inc	ah
	mov	al,0xF
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
      shd_reg_reg_imm:
	mov	al,byte [operand_size]
	or	al,al
	jz	shd_reg_reg_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      shd_reg_reg_imm_size_ok:
	call	get_byte_value
	mov	byte [value],al
	pop	bx
	pop	ax
	cmp	al,2
	je	shd_reg_reg_imm_16bit
	cmp	al,4
	je	shd_reg_reg_imm_32bit
	jmp	invalid_operand_size
      shd_reg_reg_imm_16bit:
	call	operand_16bit_prefix
	jmp	shd_reg_reg_imm_store
      shd_reg_reg_imm_32bit:
	call	operand_32bit_prefix
      shd_reg_reg_imm_store:
	mov	ah,byte [extended_code]
	mov	al,0xF
	stosw
	mov	al,bl
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
movx_instruction:
	mov	byte [base_code],0xF
	mov	byte [extended_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	mov	al,ah
	cmp	al,2
	je	movx_16bit
	cmp	al,4
	je	movx_32bit
	jmp	invalid_operand_size
      movx_16bit:
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	movx_16bit_reg
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	movx_16bit_mem_8bit
	or	al,al
	jnz	invalid_operand_size
      movx_16bit_mem_8bit:
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      movx_16bit_reg:
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	bl,3
	or	bl,al
	or	bl,%11000000
	cmp	ah,1
	jne	invalid_operand_size
	call	operand_16bit_prefix
	mov	al,0xF
	stosb
	mov	al,byte [extended_code]
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      movx_32bit:
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	movx_32bit_reg
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	movx_32bit_mem_8bit
	cmp	al,2
	je	movx_32bit_mem_16bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      movx_32bit_mem_8bit:
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      movx_32bit_mem_16bit:
	inc	byte [extended_code]
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      movx_32bit_reg:
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	bl,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,1
	je	movx_32bit_reg_8bit
	cmp	al,2
	je	movx_32bit_reg_16bit
	jmp	invalid_operand_size
      movx_32bit_reg_8bit:
	call	operand_32bit_prefix
	mov	al,0xF
	stosb
	mov	al,byte [extended_code]
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
      movx_32bit_reg_16bit:
	call	operand_32bit_prefix
	mov	al,0xF
	stosb
	mov	al,byte [extended_code]
	inc	al
	stosb
	mov	al,bl
	stosb
	jmp	instruction_assembled
bt_instruction:
	mov	byte [postbyte_register],al
	shl	al,3
	add	al,0x83
	mov	byte [extended_code],al
	mov	byte [base_code],0xF
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	bt_reg
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	push	eax
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	cmp	byte [esi],'(
	je	bt_mem_imm
	cmp	byte [esi],0x11
	jne	bt_mem_reg
	cmp	byte [esi+2],'(
	je	bt_mem_imm
      bt_mem_reg:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	al,ah
	cmp	al,2
	je	bt_mem_reg_16bit
	cmp	al,4
	je	bt_mem_reg_32bit
	jmp	invalid_operand_size
      bt_mem_reg_16bit:
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      bt_mem_reg_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      bt_mem_imm:
	xor	al,al
	xchg	al,byte [operand_size]
	push	ax
	lodsb
	call	get_size_operator
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [operand_size]
	or	al,al
	jz	bt_mem_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      bt_mem_imm_size_ok:
	mov	byte [extended_code],0xBA
	call	get_byte_value
	mov	byte [value],al
	pop	ax
	cmp	al,2
	je	bt_mem_imm_16bit
	cmp	al,4
	je	bt_mem_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	bt_mem_imm_32bit
      bt_mem_imm_16bit:
	call	operand_16bit_prefix
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      bt_mem_imm_32bit:
	call	operand_32bit_prefix
	pop	cx
	pop	bx
	pop	edx
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      bt_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	cmp	byte [esi],'(
	je	bt_reg_imm
	cmp	byte [esi],0x11
	jne	bt_reg_reg
	cmp	byte [esi+2],'(
	je	bt_reg_imm
      bt_reg_reg:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	al,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,2
	je	bt_reg_reg_16bit
	cmp	al,4
	je	bt_reg_reg_32bit
	jmp	invalid_operand_size
      bt_reg_reg_16bit:
	call	operand_16bit_prefix
	mov	ah,byte [extended_code]
	mov	al,0xF
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
      bt_reg_reg_32bit:
	call	operand_32bit_prefix
	mov	ah,byte [extended_code]
	mov	al,0xF
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
      bt_reg_imm:
	xor	al,al
	xchg	al,byte [operand_size]
	push	ax
	lodsb
	call	get_size_operator
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [operand_size]
	or	al,al
	jz	bt_reg_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      bt_reg_imm_size_ok:
	call	get_byte_value
	mov	byte [value],al
	pop	ax
	cmp	al,2
	je	bt_reg_imm_16bit
	cmp	al,4
	je	bt_reg_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
	jmp	bt_reg_imm_32bit
      bt_reg_imm_16bit:
	call	operand_16bit_prefix
	jmp	bt_reg_imm_store
      bt_reg_imm_32bit:
	call	operand_32bit_prefix
      bt_reg_imm_store:
	mov	ax,0xBA0F
	stosw
	mov	al,%11000000
	or	al,byte [postbyte_register]
	mov	ah,byte [extended_code]
	sub	ah,0x83
	or	al,ah
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
bs_instruction:
	mov	byte [extended_code],al
	mov	byte [base_code],0xF
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	cmp	al,0x10
	je	bs_reg_reg
	cmp	al,'[
	jne	invalid_argument
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,2
	je	bs_reg_mem_16bit
	cmp	al,4
	je	bs_reg_mem_32bit
	jmp	invalid_operand_size
      bs_reg_mem_16bit:
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      bs_reg_mem_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      bs_reg_reg:
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	bl,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,2
	je	bs_reg_reg_16bit
	cmp	al,4
	je	bs_reg_reg_32bit
	jmp	invalid_operand_size
      bs_reg_reg_16bit:
	call	operand_16bit_prefix
	jmp	bs_reg_reg_store
      bs_reg_reg_32bit:
	call	operand_32bit_prefix
      bs_reg_reg_store:
	mov	ah,byte [extended_code]
	mov	al,0xF
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
imul_instruction:
	mov	byte [base_code],0xF6
	mov	byte [postbyte_register],5
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	imul_reg
	cmp	al,'[
	jne	invalid_operand
      imul_mem:
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,1
	je	imul_mem_8bit
	cmp	al,2
	je	imul_mem_16bit
	cmp	al,4
	je	imul_mem_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      imul_mem_8bit:
	call	store_instruction
	jmp	instruction_assembled
      imul_mem_16bit:
	call	operand_16bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      imul_mem_32bit:
	call	operand_32bit_prefix
	inc	byte [base_code]
	call	store_instruction
	jmp	instruction_assembled
      imul_reg:
	lodsb
	call	convert_register
	cmp	byte [esi],',
	je	imul_reg_
	mov	bl,byte [postbyte_register]
	shl	bl,3
	or	bl,al
	or	bl,%11000000
	cmp	ah,1
	je	imul_reg_8bit
	cmp	ah,2
	je	imul_reg_16bit
	cmp	ah,4
	je	imul_reg_32bit
	jmp	invalid_operand_size
      imul_reg_8bit:
	mov	ah,bl
	mov	al,0xF6
	stosw
	jmp	instruction_assembled
      imul_reg_16bit:
	call	operand_16bit_prefix
	mov	ah,bl
	mov	al,0xF7
	stosw
	jmp	instruction_assembled
      imul_reg_32bit:
	call	operand_32bit_prefix
	mov	ah,bl
	mov	al,0xF7
	stosw
	jmp	instruction_assembled
      imul_reg_:
	mov	byte [postbyte_register],al
	inc	esi
	cmp	byte [esi],'(
	je	imul_reg_imm
	cmp	byte [esi],0x11
	jne	imul_reg__
	cmp	byte [esi+2],'(
	je	imul_reg_imm
      imul_reg__:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	imul_reg_reg
	cmp	al,'[
	je	imul_reg_mem
	jne	invalid_operand
      imul_reg_mem:
	call	get_address
	push	edx
	push	bx
	push	cx
	cmp	byte [esi],',
	je	imul_reg_mem_imm
	mov	al,byte [operand_size]
	cmp	al,2
	je	imul_reg_mem_16bit
	cmp	al,4
	je	imul_reg_mem_32bit
	jmp	invalid_operand_size
      imul_reg_mem_16bit:
	call	operand_16bit_prefix
	jmp	imul_reg_mem_store
      imul_reg_mem_32bit:
	call	operand_32bit_prefix
      imul_reg_mem_store:
	pop	cx
	pop	bx
	pop	edx
	mov	byte [base_code],0xF
	mov	byte [extended_code],0xAF
	call	store_instruction
	jmp	instruction_assembled
      imul_reg_mem_imm:
	inc	esi
	xor	cl,cl
	xchg	cl,byte [operand_size]
	lodsb
	call	get_size_operator
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [operand_size]
	mov	byte [operand_size],cl
	cmp	al,1
	je	imul_reg_mem_imm_8bit
	cmp	al,2
	je	imul_reg_mem_imm_16bit
	cmp	al,4
	je	imul_reg_mem_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	cl,2
	je	imul_reg_mem_imm_16bit
	cmp	cl,4
	je	imul_reg_mem_imm_32bit
	jmp	invalid_operand_size
      imul_reg_mem_imm_8bit:
	call	get_byte_value
	mov	byte [value],al
	pop	cx
	pop	bx
	pop	edx
	mov	byte [base_code],0x6B
	cmp	byte [operand_size],2
	je	imul_reg_mem_16bit_imm_8bit
	cmp	byte [operand_size],4
	je	imul_reg_mem_32bit_imm_8bit
	jmp	invalid_operand_size
      imul_reg_mem_16bit_imm_8bit:
	call	operand_16bit_prefix
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      imul_reg_mem_32bit_imm_8bit:
	call	operand_32bit_prefix
	call	store_instruction
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      imul_reg_mem_imm_16bit:
	call	get_word_value
	mov	word [value],ax
	pop	cx
	pop	bx
	pop	edx
	mov	byte [base_code],0x69
	cmp	byte [operand_size],2
	jne	invalid_operand_size
	call	operand_16bit_prefix
	call	store_instruction
	mov	ax,word [value]
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      imul_reg_mem_imm_32bit:
	call	get_dword_value
	mov	dword [value],eax
	pop	cx
	pop	bx
	pop	edx
	mov	byte [base_code],0x69
	cmp	byte [operand_size],4
	jne	invalid_operand_size
	call	operand_32bit_prefix
	call	store_instruction
	mov	eax,dword [value]
	call	mark_relocation
	stosd
	jmp	instruction_assembled
      imul_reg_imm:
	mov	dl,byte [postbyte_register]
	mov	bl,dl
	dec	esi
	jmp	imul_reg_reg_imm
      imul_reg_reg:
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	mov	dl,al
	cmp	byte [esi],',
	je	imul_reg_reg_imm
	mov	al,ah
	cmp	al,2
	je	imul_reg_reg_16bit
	cmp	al,4
	je	imul_reg_reg_32bit
	jmp	invalid_operand_size
      imul_reg_reg_16bit:
	call	operand_16bit_prefix
	jmp	imul_reg_reg_store
      imul_reg_reg_32bit:
	call	operand_32bit_prefix
      imul_reg_reg_store:
	mov	ax,0xAF0F
	stosw
	mov	al,dl
	shl	bl,3
	or	al,bl
	or	al,%11000000
	stosb
	jmp	instruction_assembled
      imul_reg_reg_imm:
	inc	esi
	xor	cl,cl
	xchg	cl,byte [operand_size]
	lodsb
	call	get_size_operator
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [operand_size]
	mov	byte [operand_size],cl
	cmp	al,1
	je	imul_reg_reg_imm_8bit
	cmp	al,2
	je	imul_reg_reg_imm_16bit
	cmp	al,4
	je	imul_reg_reg_imm_32bit
	or	al,al
	jnz	invalid_operand_size
	cmp	cl,2
	je	imul_reg_reg_imm_16bit
	cmp	cl,4
	je	imul_reg_reg_imm_32bit
	jmp	invalid_operand_size
      imul_reg_reg_imm_8bit:
	push	bx
	push	dx
	call	get_byte_value
	pop	dx
	pop	bx
      imul_reg_reg_imm_8bit_store:
	mov	byte [value],al
	cmp	byte [operand_size],2
	je	imul_reg_reg_16bit_imm_8bit
	cmp	byte [operand_size],4
	je	imul_reg_reg_32bit_imm_8bit
	jmp	invalid_operand_size
      imul_reg_reg_16bit_imm_8bit:
	call	operand_16bit_prefix
	mov	al,0x6B
	stosb
	mov	al,dl
	shl	bl,3
	or	al,bl
	or	al,%11000000
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      imul_reg_reg_32bit_imm_8bit:
	call	operand_32bit_prefix
	mov	al,0x6B
	stosb
	mov	al,dl
	shl	bl,3
	or	al,bl
	or	al,%11000000
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      imul_reg_reg_imm_16bit:
	push	bx
	push	dx
	call	get_word_value
	pop	dx
	pop	bx
	cmp	byte [value_type],0
	jne	imul_reg_reg_imm_16bit_forced
	cmp	ax,-0x80
	jl	imul_reg_reg_imm_16bit_forced
	cmp	ax,0x80
	jl	imul_reg_reg_imm_8bit_store
      imul_reg_reg_imm_16bit_forced:
	mov	word [value],ax
	call	operand_16bit_prefix
	mov	al,0x69
	stosb
	mov	al,dl
	shl	bl,3
	or	al,bl
	or	al,%11000000
	stosb
	mov	ax,word [value]
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      imul_reg_reg_imm_32bit:
	push	bx
	push	dx
	call	get_dword_value
	pop	dx
	pop	bx
	cmp	byte [value_type],0
	jne	imul_reg_reg_imm_32bit_forced
	cmp	ax,-0x80
	jl	imul_reg_reg_imm_32bit_forced
	cmp	ax,0x80
	jl	imul_reg_reg_imm_8bit_store
      imul_reg_reg_imm_32bit_forced:
	mov	dword [value],eax
	call	operand_32bit_prefix
	mov	al,0x69
	stosb
	mov	al,dl
	shl	bl,3
	or	al,bl
	or	al,%11000000
	stosb
	mov	eax,dword [value]
	call	mark_relocation
	stosd
	jmp	instruction_assembled
in_instruction:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	or	al,al
	jnz	invalid_operand
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	al,ah
	push	ax
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	in_imm
	cmp	al,0x10
	je	in_reg
	jmp	invalid_operand
      in_reg:
	lodsb
	cmp	al,0x22
	jne	invalid_operand
	pop	ax
	cmp	al,1
	je	in_al_dx
	cmp	al,2
	je	in_ax_dx
	cmp	al,4
	je	in_eax_dx
	jmp	invalid_operand_size
      in_al_dx:
	mov	al,0xEC
	stosb
	jmp	instruction_assembled
      in_ax_dx:
	call	operand_16bit_prefix
	mov	al,0xED
	stosb
	jmp	instruction_assembled
      in_eax_dx:
	call	operand_32bit_prefix
	mov	al,0xED
	stosb
	jmp	instruction_assembled
      in_imm:
	mov	al,byte [operand_size]
	or	al,al
	jz	in_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      in_imm_size_ok:
	call	get_byte_value
	mov	dl,al
	pop	ax
	cmp	al,1
	je	in_al_imm
	cmp	al,2
	je	in_ax_imm
	cmp	al,4
	je	in_eax_imm
	jmp	invalid_operand_size
      in_al_imm:
	mov	al,0xE4
	stosb
	mov	al,dl
	stosb
	jmp	instruction_assembled
      in_ax_imm:
	call	operand_16bit_prefix
	mov	al,0xE5
	stosb
	mov	al,dl
	stosb
	jmp	instruction_assembled
      in_eax_imm:
	call	operand_32bit_prefix
	mov	al,0xE5
	stosb
	mov	al,dl
	stosb
	jmp	instruction_assembled
out_instruction:
	lodsb
	call	get_size_operator
	cmp	al,'(
	je	out_imm
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	cmp	al,0x22
	jne	invalid_operand
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	or	al,al
	jnz	invalid_operand
	mov	al,ah
	cmp	al,1
	je	out_dx_al
	cmp	al,2
	je	out_dx_ax
	cmp	al,4
	je	out_dx_eax
	jmp	invalid_operand_size
      out_dx_al:
	mov	al,0xEE
	stosb
	jmp	instruction_assembled
      out_dx_ax:
	call	operand_16bit_prefix
	mov	al,0xEF
	stosb
	jmp	instruction_assembled
      out_dx_eax:
	call	operand_32bit_prefix
	mov	al,0xEF
	stosb
	jmp	instruction_assembled
      out_imm:
	mov	al,byte [operand_size]
	or	al,al
	jz	out_imm_size_ok
	cmp	al,1
	jne	invalid_operand_size
      out_imm_size_ok:
	call	get_byte_value
	mov	byte [value],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	mov	byte [operand_size],0
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	or	al,al
	jnz	invalid_operand
	mov	al,ah
	cmp	al,1
	je	out_imm_al
	cmp	al,2
	je	out_imm_ax
	cmp	al,4
	je	out_imm_eax
	jmp	invalid_operand_size
      out_imm_al:
	mov	al,0xE6
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      out_imm_ax:
	call	operand_16bit_prefix
	mov	al,0xE7
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
      out_imm_eax:
	call	operand_32bit_prefix
	mov	al,0xE7
	stosb
	mov	al,byte [value]
	stosb
	jmp	instruction_assembled
lar_instruction:
	mov	byte [extended_code],al
	mov	byte [base_code],0xF
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	lar_reg_reg
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	mov	al,byte [operand_size]
	cmp	al,2
	je	lar_16bit
	cmp	al,4
	je	lar_32bit
	jmp	invalid_operand_size
      lar_16bit:
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      lar_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      lar_reg_reg:
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	bl,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,2
	je	lar_reg_reg_16bit
	cmp	al,4
	je	lar_reg_reg_32bit
	jmp	invalid_operand_size
      lar_reg_reg_32bit:
	call	operand_32bit_prefix
	jmp	lar_reg_reg_store
      lar_reg_reg_16bit:
	call	operand_16bit_prefix
      lar_reg_reg_store:
	mov	al,0xF
	mov	ah,byte [extended_code]
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
invlpg_instruction:
	mov	byte [base_code],0xF
	mov	byte [extended_code],1
	mov	byte [postbyte_register],7
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	call	store_instruction
	jmp	instruction_assembled
basic_486_instruction:
	mov	byte [base_code],0xF
	mov	byte [extended_code],al
	lodsb
	call	get_size_operator
	cmp	al,0x10
	je	basic_486_reg
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	push	edx
	push	bx
	push	cx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	pop	cx
	pop	bx
	pop	edx
	mov	al,ah
	cmp	al,1
	je	basic_486_mem_reg_8bit
	cmp	al,2
	je	basic_486_mem_reg_16bit
	cmp	al,4
	je	basic_486_mem_reg_32bit
	jmp	invalid_operand_size
      basic_486_mem_reg_8bit:
	call	store_instruction
	jmp	instruction_assembled
      basic_486_mem_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [extended_code]
	call	store_instruction
	jmp	instruction_assembled
      basic_486_mem_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [extended_code]
	call	store_instruction
	jmp	instruction_assembled
      basic_486_reg:
	lodsb
	call	convert_register
	mov	byte [postbyte_register],al
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	bl,byte [postbyte_register]
	shl	al,3
	or	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,1
	je	basic_486_reg_reg_8bit
	cmp	al,2
	je	basic_486_reg_reg_16bit
	cmp	al,4
	je	basic_486_reg_reg_32bit
	jmp	invalid_operand_size
      basic_486_reg_reg_32bit:
	call	operand_32bit_prefix
	inc	byte [extended_code]
	jmp	basic_486_reg_reg_8bit
      basic_486_reg_reg_16bit:
	call	operand_16bit_prefix
	inc	byte [extended_code]
      basic_486_reg_reg_8bit:
	mov	al,0xF
	mov	ah,byte [extended_code]
	stosw
	mov	al,bl
	stosb
	jmp	instruction_assembled
bswap_instruction:
	lodsb
	call	get_size_operator
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	call	convert_register
	mov	ah,al
	add	ah,0xC8
	cmp	ah,4
	jne	invalid_operand_size
	call	operand_32bit_prefix
	mov	al,0xF
	stosw
	jmp	instruction_assembled
conditional_jump:
	mov	byte [base_code],al
	lodsb
	call	get_jump_operator
	cmp	byte [jump_type],2
	je	invalid_operand
	call	get_size_operator
	cmp	al,'(
	jne	invalid_operand
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],1
	je	invalid_use_of_symbol
	sub	eax,edi
	add	eax,dword [org_start]
	sub	eax,2
	cmp	dword [org_sib],0
	jne	invalid_use_of_symbol
	mov	bl,byte [operand_size]
	cmp	bl,1
	je	conditional_jump_8bit
	cmp	bl,2
	je	conditional_jump_16bit
	cmp	bl,4
	je	conditional_jump_32bit
	or	bl,bl
	jnz	invalid_operand_size
	cmp	eax,0x80
	jb	conditional_jump_8bit
	cmp	eax,-0x80
	jae	conditional_jump_8bit
	cmp	byte [code_type],16
	je	conditional_jump_16bit
      conditional_jump_32bit:
	sub	eax,4
	mov	edx,eax
	mov	ecx,edi
	call	operand_32bit_prefix
	sub	edx,edi
	add	edx,ecx
	mov	ah,byte [base_code]
	add	ah,0x10
	mov	al,0xF
	stosw
	mov	eax,edx
	stosd
	jmp	instruction_assembled
      conditional_jump_16bit:
	sub	eax,2
	mov	edx,eax
	mov	ecx,edi
	call	operand_16bit_prefix
	sub	edx,edi
	add	edx,ecx
	mov	ah,byte [base_code]
	add	ah,0x10
	mov	al,0xF
	stosw
	mov	eax,edx
	stosw
	cmp	eax,0x10000
	jge	jump_out_of_range
	cmp	eax,-0x10000
	jl	jump_out_of_range
	jmp	instruction_assembled
      conditional_jump_8bit:
	mov	edx,eax
	mov	ah,al
	mov	al,byte [base_code]
	stosw
	cmp	edx,0x80
	jge	jump_out_of_range
	cmp	edx,-0x80
	jl	jump_out_of_range
	jmp	instruction_assembled
      jump_out_of_range:
	cmp	dword [error_line],0
	jne	instruction_assembled
	mov	eax,dword [current_line]
	mov	dword [error_line],eax
	mov	dword [error],relative_jump_out_of_range
	jmp	instruction_assembled
loop_instruction_16bit:
	mov	cl,al
	call	address_16bit_prefix
	mov	al,cl
	jmp	loop_instruction
loop_instruction_32bit:
	mov	cl,al
	call	address_32bit_prefix
	mov	al,cl
loop_instruction:
	mov	byte [base_code],al
	lodsb
	call	get_jump_operator
	cmp	byte [jump_type],2
	je	invalid_operand
	call	get_size_operator
	cmp	al,'(
	jne	invalid_operand
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	cmp	byte [value_type],1
	je	invalid_use_of_symbol
	sub	eax,edi
	add	eax,dword [org_start]
	cmp	dword [org_sib],0
	jne	invalid_use_of_symbol
	mov	bl,byte [operand_size]
	cmp	bl,1
	je	loop_8bit
	or	bl,bl
	jnz	invalid_operand_size
      loop_8bit:
	sub	eax,2
	mov	edx,eax
	mov	al,byte [base_code]
	stosb
	mov	eax,edx
	stosb
	cmp	eax,0x80
	jge	jump_out_of_range
	cmp	eax,-0x80
	jl	jump_out_of_range
	jmp	instruction_assembled
call_instruction:
	mov	byte [postbyte_register],%10
	mov	byte [base_code],0xE8
	mov	byte [extended_code],0x9A
	jmp	process_jmp
jmp_instruction:
	mov	byte [postbyte_register],%100
	mov	byte [base_code],0xE9
	mov	byte [extended_code],0xEA
      process_jmp:
	lodsb
	call	get_jump_operator
	call	get_size_operator
	cmp	al,0x10
	je	jmp_reg
	cmp	al,'(
	je	jmp_imm
	cmp	al,'[
	jne	invalid_operand
      jmp_mem:
	call	get_address
	mov	byte [base_code],0xFF
	mov	edx,eax
	mov	al,byte [operand_size]
	or	al,al
	jz	jmp_mem_size_not_specified
	cmp	al,2
	je	jmp_mem_16bit
	cmp	al,4
	je	jmp_mem_32bit
	cmp	al,6
	je	jmp_mem_48bit
	jmp	invalid_operand_size
      jmp_mem_size_not_specified:
	cmp	byte [jump_type],2
	je	jmp_mem_far
	cmp	byte [jump_type],1
	je	jmp_mem_near
	cmp	byte [current_pass],0
	jne	operand_size_not_specified
	cmp	byte [next_pass_needed],0
	je	operand_size_not_specified
      jmp_mem_near:
	cmp	byte [code_type],16
	je	jmp_mem_16bit
	jmp	jmp_mem_near_32bit
      jmp_mem_far:
	cmp	byte [code_type],16
	je	jmp_mem_far_32bit
      jmp_mem_48bit:
	cmp	byte [jump_type],1
	je	invalid_operand_size
	call	operand_32bit_prefix
	inc	byte [postbyte_register]
	call	store_instruction
	jmp	instruction_assembled
      jmp_mem_32bit:
	cmp	byte [jump_type],2
	je	jmp_mem_far_32bit
	cmp	byte [jump_type],1
	je	jmp_mem_near_32bit
	cmp	byte [code_type],16
	je	jmp_mem_far_32bit
      jmp_mem_near_32bit:
	call	operand_32bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      jmp_mem_far_32bit:
	call	operand_16bit_prefix
	inc	byte [postbyte_register]
	call	store_instruction
	jmp	instruction_assembled
      jmp_mem_16bit:
	cmp	byte [jump_type],2
	je	invalid_operand_size
	call	operand_16bit_prefix
	call	store_instruction
	jmp	instruction_assembled
      jmp_reg:
	lodsb
	call	convert_register
	mov	bl,al
	or	bl,%11000000
	mov	al,ah
	cmp	al,2
	je	jmp_reg_16bit
	cmp	al,4
	je	jmp_reg_32bit
	jmp	invalid_operand_size
      jmp_reg_32bit:
	cmp	byte [jump_type],2
	je	jmp_reg_far32bit
	cmp	byte [jump_type],1
	je	jmp_reg_near32bit
	cmp	byte [code_type],16
	je	jmp_reg_far32bit
      jmp_reg_near32bit:
	call	operand_32bit_prefix
	mov	al,byte [postbyte_register]
	shl	al,3
	or	bl,al
	mov	ah,bl
	mov	al,0xFF
	stosw
	jmp	instruction_assembled
      jmp_reg_far32bit:
	call	operand_32bit_prefix
	mov	al,byte [postbyte_register]
	inc	al
	shl	al,3
	or	bl,al
	mov	ah,bl
	mov	al,0xFF
	stosw
	jmp	instruction_assembled
      jmp_reg_16bit:
	cmp	byte [jump_type],2
	je	invalid_operand_size
	call	operand_16bit_prefix
	mov	al,byte [postbyte_register]
	shl	al,3
	or	bl,al
	mov	ah,bl
	mov	al,0xFF
	stosw
	jmp	instruction_assembled
      jmp_imm:
	push	esi
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	pop	ebx
	cmp	byte [esi],':
	je	jmp_far
	cmp	byte [value_type],1
	je	invalid_use_of_symbol
	cmp	byte [jump_type],2
	je	invalid_operand
	sub	eax,edi
	add	eax,dword [org_start]
	sub	eax,2
	cmp	dword [org_sib],0
	jne	invalid_use_of_symbol
	mov	bl,byte [operand_size]
	cmp	bl,1
	je	jmp_8bit
	cmp	bl,2
	je	jmp_16bit
	cmp	bl,4
	je	jmp_32bit
	or	bl,bl
	jnz	invalid_operand_size
	cmp	byte [base_code],0xE9
	jne	jmp_no8bit
	cmp	eax,0x80
	jb	jmp_8bit
	cmp	eax,-0x80
	jae	jmp_8bit
      jmp_no8bit:
	cmp	byte [code_type],32
	je	jmp_32bit
      jmp_16bit:
	dec	eax
	mov	edx,eax
	mov	ecx,edi
	call	operand_16bit_prefix
	sub	edx,edi
	add	edx,ecx
	mov	al,byte [base_code]
	stosb
	mov	eax,edx
	stosw
	cmp	eax,0x10000
	jge	jump_out_of_range
	cmp	eax,-0x10000
	jl	jump_out_of_range
	jmp	instruction_assembled
      jmp_32bit:
	sub	eax,3
	mov	edx,eax
	mov	ecx,edi
	call	operand_32bit_prefix
	sub	edx,edi
	add	edx,ecx
	mov	al,byte [base_code]
	stosb
	mov	eax,edx
	stosd
	jmp	instruction_assembled
      jmp_8bit:
	cmp	byte [base_code],0xE9
	jne	invalid_operand_size
	mov	edx,eax
	mov	ah,al
	mov	al,0xEB
	stosw
	cmp	edx,0x80
	jge	jump_out_of_range
	cmp	edx,-0x80
	jl	jump_out_of_range
	jmp	instruction_assembled
      jmp_far:
	cmp	byte [jump_type],1
	je	invalid_operand
	mov	esi,ebx
	call	get_word_value
	mov	dx,ax
	mov	bl,byte [operand_size]
	cmp	bl,4
	je	jmp_far_16bit
	cmp	bl,6
	je	jmp_far_32bit
	or	bl,bl
	jnz	invalid_operand_size
	cmp	byte [code_type],32
	je	jmp_far_32bit
      jmp_far_16bit:
	inc	esi
	lodsb
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [value_type]
	push	ax
	cmp	byte [esi],'.
	je	invalid_value
	call	get_word_value
	mov	ebx,eax
	call	operand_16bit_prefix
	mov	al,byte [extended_code]
	stosb
	mov	ax,bx
	call	mark_relocation
	stosw
	pop	ax
	mov	byte [value_type],al
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	instruction_assembled
      jmp_far_32bit:
	inc	esi
	lodsb
	cmp	al,'(
	jne	invalid_operand
	mov	al,byte [value_type]
	push	ax
	cmp	byte [esi],'.
	je	invalid_value
	call	get_dword_value
	mov	ebx,eax
	call	operand_32bit_prefix
	mov	al,byte [extended_code]
	stosb
	mov	eax,ebx
	call	mark_relocation
	stosd
	pop	ax
	mov	byte [value_type],al
	mov	ax,dx
	call	mark_relocation
	stosw
	jmp	instruction_assembled
ins_instruction:
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	cmp	bh,0x27
	je	ins_16bit
	cmp	bh,0x47
	jne	invalid_address
	call	address_32bit_prefix
	jmp	ins_store
      ins_16bit:
	call	address_16bit_prefix
      ins_store:
	cmp	byte [segment_register],1
	ja	invalid_address
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	cmp	al,0x22
	jne	invalid_operand
	mov	al,0x6C
	cmp	byte [operand_size],1
	je	simple_instruction
	inc	al
	cmp	byte [operand_size],2
	je	simple_instruction_16bit
	cmp	byte [operand_size],4
	je	simple_instruction_32bit
	cmp	byte [operand_size],0
	je	operand_size_not_specified
	jmp	invalid_operand_size
outs_instruction:
	lodsb
	cmp	al,0x10
	jne	invalid_operand
	lodsb
	cmp	al,0x22
	jne	invalid_operand
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	cmp	bh,0x26
	je	outs_16bit
	cmp	bh,0x46
	jne	invalid_address
	call	address_32bit_prefix
	jmp	outs_store
      outs_16bit:
	call	address_16bit_prefix
      outs_store:
	cmp	byte [segment_register],4
	je	outs_segment_ok
	call	store_segment_prefix
      outs_segment_ok:
	mov	al,0x6E
	cmp	byte [operand_size],1
	je	simple_instruction
	inc	al
	cmp	byte [operand_size],2
	je	simple_instruction_16bit
	cmp	byte [operand_size],4
	je	simple_instruction_32bit
	cmp	byte [operand_size],0
	je	operand_size_not_specified
	jmp	invalid_operand_size
movs_instruction:
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	cmp	byte [segment_register],1
	ja	invalid_address
	push	bx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	pop	dx
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	mov	al,dh
	mov	ah,bh
	shr	al,4
	shr	ah,4
	cmp	al,ah
	jne	address_sizes_do_not_agree
	and	bh,%111
	and	dh,%111
	cmp	bh,6
	jne	invalid_address
	cmp	dh,7
	jne	invalid_address
	cmp	al,2
	je	movs_16bit
	cmp	al,4
	jne	invalid_address
	call	address_32bit_prefix
	jmp	movs_store
      movs_16bit:
	call	address_16bit_prefix
      movs_store:
	cmp	byte [segment_register],4
	je	movs_segment_ok
	call	store_segment_prefix
      movs_segment_ok:
	mov	al,0xA4
	mov	bl,byte [operand_size]
	cmp	bl,1
	je	simple_instruction
	inc	al
	cmp	bl,2
	je	simple_instruction_16bit
	cmp	bl,4
	je	simple_instruction_32bit
	or	bl,bl
	jz	operand_size_not_specified
	jmp	invalid_operand_size
lods_instruction:
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	cmp	bh,0x26
	je	lods_16bit
	cmp	bh,0x46
	jne	invalid_address
	call	address_32bit_prefix
	jmp	lods_store
      lods_16bit:
	call	address_16bit_prefix
      lods_store:
	cmp	byte [segment_register],4
	je	lods_segment_ok
	call	store_segment_prefix
      lods_segment_ok:
	mov	al,0xAC
	cmp	byte [operand_size],1
	je	simple_instruction
	inc	al
	cmp	byte [operand_size],2
	je	simple_instruction_16bit
	cmp	byte [operand_size],4
	je	simple_instruction_32bit
	cmp	byte [operand_size],0
	je	operand_size_not_specified
	jmp	invalid_operand_size
stos_instruction:
	mov	byte [base_code],al
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	cmp	bh,0x27
	je	stos_16bit
	cmp	bh,0x47
	jne	invalid_address
	call	address_32bit_prefix
	jmp	stos_store
      stos_16bit:
	call	address_16bit_prefix
      stos_store:
	cmp	byte [segment_register],1
	ja	invalid_address
	mov	al,byte [base_code]
	cmp	byte [operand_size],1
	je	simple_instruction
	inc	al
	cmp	byte [operand_size],2
	je	simple_instruction_16bit
	cmp	byte [operand_size],4
	je	simple_instruction_32bit
	cmp	byte [operand_size],0
	je	operand_size_not_specified
	jmp	invalid_operand_size
cmps_instruction:
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	mov	al,byte [segment_register]
	push	ax
	push	bx
	lodsb
	cmp	al,',
	jne	invalid_operand
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	pop	dx
	pop	ax
	cmp	byte [segment_register],1
	ja	invalid_address
	mov	byte [segment_register],al
	mov	al,dh
	mov	ah,bh
	shr	al,4
	shr	ah,4
	cmp	al,ah
	jne	address_sizes_do_not_agree
	and	bh,%111
	and	dh,%111
	cmp	bh,7
	jne	invalid_address
	cmp	dh,6
	jne	invalid_address
	cmp	al,2
	je	cmps_16bit
	cmp	al,4
	jne	invalid_address
	call	address_32bit_prefix
	jmp	cmps_store
      cmps_16bit:
	call	address_16bit_prefix
      cmps_store:
	cmp	byte [segment_register],4
	je	cmps_segment_ok
	call	store_segment_prefix
      cmps_segment_ok:
	mov	al,0xA6
	mov	bl,byte [operand_size]
	cmp	bl,1
	je	simple_instruction
	inc	al
	cmp	bl,2
	je	simple_instruction_16bit
	cmp	bl,4
	je	simple_instruction_32bit
	or	bl,bl
	jz	operand_size_not_specified
	jmp	invalid_operand_size
xlat_instruction:
	lodsb
	call	get_size_operator
	cmp	al,'[
	jne	invalid_operand
	call	get_address
	or	eax,eax
	jnz	invalid_address
	or	bl,ch
	jnz	invalid_address
	cmp	bh,0x23
	je	xlat_16bit
	cmp	bh,0x43
	jne	invalid_address
	call	address_32bit_prefix
	jmp	xlat_store
      xlat_16bit:
	call	address_16bit_prefix
      xlat_store:
	call	store_segment_prefix_if_necessary
	mov	al,0xD7
	cmp	byte [operand_size],1
	jbe	simple_instruction
	jmp	invalid_operand_size
cmpsd_instruction:
	mov	al,0xA7
	mov	ah,[esi]
	or	ah,ah
	jmp	simple_instruction_32bit
movsd_instruction:
	mov	al,0xA5
	mov	ah,[esi]
	or	ah,ah
	jmp	simple_instruction_32bit
convert_register:
	mov	ah,al
	shr	ah,4
	and	al,%111
	cmp	ah,4
	ja	invalid_operand
      match_register_size:
	cmp	ah,byte [operand_size]
	je	register_size_ok
	cmp	byte [operand_size],0
	jne	operand_sizes_do_not_match
	mov	byte [operand_size],ah
      register_size_ok:
	ret
get_size_operator:
	xor	ah,ah
	cmp	al,0x11
	jne	operand_size_ok
	lodsw
	xchg	al,ah
	mov	byte [forced_size],1
	cmp	ah,byte [operand_size]
	je	forced_ok
	cmp	byte [operand_size],0
	jne	operand_sizes_do_not_match
	mov	byte [operand_size],ah
      forced_ok:
	ret
      operand_size_ok:
	cmp	al,'[
	jne	forced_ok
	mov	byte [forced_size],0
	ret
get_jump_operator:
	mov	byte [jump_type],0
	cmp	al,0x12
	jne	jump_operator_ok
	lodsw
	mov	byte [jump_type],al
	mov	al,ah
      jump_operator_ok:
	ret
operand_16bit_prefix:
	cmp	byte [code_type],16
	je	size_prefix_ok
	mov	al,0x66
	stosb
	ret
operand_32bit_prefix:
	cmp	byte [code_type],32
	je	size_prefix_ok
	mov	al,0x66
	stosb
      size_prefix_ok:
	ret
store_segment_prefix_if_necessary:
	mov	al,byte [segment_register]
	or	al,al
	jz	segment_prefix_ok
	cmp	al,3
	je	ss_prefix
	cmp	al,4
	ja	segment_prefix_386
	jb	segment_prefix
	cmp	bh,0x25
	je	segment_prefix
	cmp	bh,0x45
	je	segment_prefix
	cmp	bh,0x44
	je	segment_prefix
	ret
      ss_prefix:
	cmp	bh,0x25
	je	segment_prefix_ok
	cmp	bh,0x45
	je	segment_prefix_ok
	cmp	bh,0x44
	je	segment_prefix_ok
	jmp	segment_prefix
store_segment_prefix:
	mov	al,byte [segment_register]
	or	al,al
	jz	segment_prefix_ok
	cmp	al,5
	jae	segment_prefix_386
      segment_prefix:
	dec	al
	shl	al,3
	add	al,0x26
	stosb
	jmp	segment_prefix_ok
      segment_prefix_386:
	add	al,0x64-5
	stosb
      segment_prefix_ok:
	ret
store_instruction:
	call	store_segment_prefix_if_necessary
      store_instruction_main:
	or	bx,bx
	jz	address_immediate
	mov	al,bl
	or	al,bh
	and	al,%11110000
	cmp	al,0x40
	je	postbyte_32bit
	call	address_16bit_prefix
	call	store_instruction_code
	cmp	bx,0x2326
	je	address_bx_si
	cmp	bx,0x2623
	je	address_bx_si
	cmp	bx,0x2327
	je	address_bx_di
	cmp	bx,0x2723
	je	address_bx_di
	cmp	bx,0x2526
	je	address_bp_si
	cmp	bx,0x2625
	je	address_bp_si
	cmp	bx,0x2527
	je	address_bp_di
	cmp	bx,0x2725
	je	address_bp_di
	cmp	bx,0x2600
	je	address_si
	cmp	bx,0x2700
	je	address_di
	cmp	bx,0x2300
	je	address_bx
	cmp	bx,0x2500
	je	address_bp
	jmp	invalid_address
      address_bx_si:
	xor	al,al
	jmp	postbyte_16bit
      address_bx_di:
	mov	al,1
	jmp	postbyte_16bit
      address_bp_si:
	mov	al,%10
	jmp	postbyte_16bit
      address_bp_di:
	mov	al,%11
	jmp	postbyte_16bit
      address_si:
	mov	al,%100
	jmp	postbyte_16bit
      address_di:
	mov	al,%101
	jmp	postbyte_16bit
      address_bx:
	mov	al,%111
	jmp	postbyte_16bit
      address_bp:
	mov	al,%110
      postbyte_16bit:
	cmp	ch,1
	je	address_8bit_value
	cmp	ch,2
	je	address_16bit_value
	or	ch,ch
	jnz	address_sizes_do_not_agree
	or	edx,edx
	jz	address
	cmp	edx,0x80
	jb	address_8bit_value
	cmp	edx,-0x80
	jae	address_8bit_value
      address_16bit_value:
	or	al,%10000000
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	mov	eax,edx
	stosw
	cmp	edx,0x10000
	jge	value_out_of_range
	cmp	edx,-0x8000
	jl	value_out_of_range
	ret
      address_8bit_value:
	or	al,%01000000
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	mov	al,dl
	stosb
	cmp	edx,0x80
	jge	value_out_of_range
	cmp	edx,-0x80
	jl	value_out_of_range
	ret
      address:
	cmp	al,%110
	je	address_8bit_value
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	ret
      postbyte_32bit:
	call	address_32bit_prefix
	call	store_instruction_code
	cmp	bl,0x44
	je	invalid_address
	or	cl,cl
	jz	only_base_register
      base_and_index:
	mov	al,%100
	xor	ah,ah
	cmp	cl,1
	je	scale_ok
	cmp	cl,2
	je	scale_1
	cmp	cl,4
	je	scale_2
	or	ah,%11000000
	jmp	scale_ok
      scale_2:
	or	ah,%10000000
	jmp	scale_ok
      scale_1:
	or	ah,%01000000
      scale_ok:
	or	bh,bh
	jz	only_index_register
	and	bl,%111
	shl	bl,3
	or	ah,bl
	and	bh,%111
	or	ah,bh
	cmp	ch,1
	je	sib_address_8bit_value
	test	ch,4
	jnz	sib_address_32bit_value
	cmp	ch,2
	je	address_sizes_do_not_agree
	cmp	bh,5
	je	address_value
	or	edx,edx
	jz	sib_address
      address_value:
	cmp	edx,0x80
	jb	sib_address_8bit_value
	cmp	edx,-0x80
	jae	sib_address_8bit_value
      sib_address_32bit_value:
	or	al,%10000000
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosw
	jmp	store_address_32bit_value
      sib_address_8bit_value:
	or	al,%01000000
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosw
	mov	al,dl
	stosb
	cmp	edx,0x80
	jge	value_out_of_range
	cmp	edx,-0x80
	jl	value_out_of_range
	ret
      sib_address:
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosw
	ret
      only_index_register:
	or	ah,%101
	and	bl,%111
	shl	bl,3
	or	ah,bl
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosw
	test	ch,4
	jnz	store_address_32bit_value
	or	ch,ch
	jnz	invalid_address_size
	jmp	store_address_32bit_value
      zero_index_register:
	mov	bl,4
	mov	cl,1
	jmp	base_and_index
      only_base_register:
	mov	al,bh
	and	al,%111
	cmp	al,4
	je	zero_index_register
	cmp	ch,1
	je	simple_address_8bit_value
	test	ch,4
	jnz	simple_address_32bit_value
	cmp	ch,2
	je	address_sizes_do_not_agree
	or	edx,edx
	jz	simple_address
	cmp	edx,0x80
	jb	simple_address_8bit_value
	cmp	edx,-0x80
	jae	simple_address_8bit_value
      simple_address_32bit_value:
	or	al,%10000000
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	jmp	store_address_32bit_value
      simple_address_8bit_value:
	or	al,%01000000
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	mov	al,dl
	stosb
	cmp	edx,0x80
	jge	value_out_of_range
	cmp	edx,-0x80
	jl	value_out_of_range
	ret
      simple_address:
	cmp	al,5
	je	simple_address_8bit_value
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	ret
      address_immediate:
	test	ch,4
	jnz	address_immediate_32bit
	cmp	ch,2
	je	address_immediate_16bit
	or	ch,ch
	jnz	invalid_address_size
	cmp	byte [code_type],16
	je	addressing_16bit
      address_immediate_32bit:
	call	address_32bit_prefix
	call	store_instruction_code
	mov	al,%101
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
      store_address_32bit_value:
	test	ch,0x80
	jz	address_relocation_ok
	push	word [value_type]
	mov	byte [value_type],2
	call	mark_relocation
	pop	ax
	mov	byte [value_type],al
      address_relocation_ok:
	mov	eax,edx
	stosd
	ret
      addressing_16bit:
	cmp	edx,0x10000
	jge	address_immediate_32bit
	cmp	edx,-0x8000
	jl	address_immediate_32bit
	movzx	edx,dx
      address_immediate_16bit:
	call	address_16bit_prefix
	call	store_instruction_code
	mov	al,%110
	mov	cl,byte [postbyte_register]
	shl	cl,3
	or	al,cl
	stosb
	mov	eax,edx
	stosw
	cmp	edx,0x10000
	jge	value_out_of_range
	cmp	edx,-0x8000
	jl	value_out_of_range
	ret
      store_instruction_code:
	mov	al,byte [base_code]
	stosb
	cmp	al,0xF
	jne	instruction_code_ok
      store_extended_code:
	mov	al,byte [extended_code]
	stosb
      instruction_code_ok:
	ret
      address_16bit_prefix:
	cmp	byte [code_type],16
	je	instruction_prefix_ok
	mov	al,0x67
	stosb
	ret
      address_32bit_prefix:
	cmp	byte [code_type],32
	je	instruction_prefix_ok
	mov	al,0x67
	stosb
      instruction_prefix_ok:
	ret

;%include '../formats.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

format_directive:
	cmp	edi,dword [code_start]
	jne	unexpected_instruction
	cmp	byte [output_format],0
	jne	unexpected_instruction
	lodsb
	cmp	al,0x18
	jne	invalid_argument
	lodsb
	mov	byte [output_format],al
	jmp	instruction_assembled
entry_directive:
	bts	dword [format_flags],1
	jc	symbol_already_defined
	jmp	illegal_instruction
stack_directive:
	bts	dword [format_flags],2
	jc	symbol_already_defined
	jmp	illegal_instruction
heap_directive:
	bts	dword [format_flags],3
	jc	symbol_already_defined
	jmp	illegal_instruction
mark_relocation:
	ret

;%include '../tables.inc'

; flat assembler source
; Copyright (c) 1999-2001, Tomasz Grysztar
; All rights reserved.

get_operator:
	push	esi
	push	ebp
	mov	ebp,1
	cmp	byte [esi],0x1A
	jne	operator_start
	inc	esi
	lodsb
	movzx	ebp,al
      operator_start:
	mov	edx,esi
      check_operator:
	mov	esi,edx
	movzx	ecx,byte [edi]
	jecxz	no_operator
	inc	edi
	mov	ebx,edi
	add	ebx,ecx
	cmp	ecx,ebp
	jne	next_operator
	repe
	cmpsb
	je	operator_found
      next_operator:
	mov	edi,ebx
	inc	edi
	jmp	check_operator
      no_operator:
	xor	al,al
	pop	ebp
	pop	esi
	ret
      operator_found:
	pop	ebp
	pop	eax
	mov	al,[edi]
	ret

get_symbol:
	mov	edx,esi
	mov	ebp,ecx
      scan_symbols:
	mov	esi,edx
	movzx	eax,byte [edi]
	or	al,al
	jz	no_symbol
	mov	ecx,ebp
	inc	edi
	mov	ebx,edi
	add	ebx,eax
	mov	ah,[esi]
	cmp	ah,[edi]
	jb	no_symbol
	ja	next_symbol
	cmp	cl,al
	jne	next_symbol
	repe
	cmpsb
	jb	no_symbol
	je	symbol_ok
      next_symbol:
	mov	edi,ebx
	add	edi,2
	jmp	scan_symbols
      no_symbol:
	mov	esi,edx
	mov	ecx,ebp
	stc
	ret
      symbol_ok:
	mov	ax,[ebx]
	clc
	ret

get_instruction:
	mov	edx,esi
	mov	ebp,ecx
	cmp	ecx,11
	ja	no_instruction
	sub	cl,2
	jc	no_instruction
	movzx	edi,word [ecx*2+instructions]  ; Offset must come last.
	add	edi,instructions
      scan_instructions:
	mov	esi,edx
	mov	al,[edi]
	or	al,al
	jz	no_instruction
	mov	ecx,ebp
	mov	ebx,edi
	add	ebx,ecx
	repe
	cmpsb
	jb	no_instruction
	je	instruction_ok
      next_instruction:
	mov	edi,ebx
	add	edi,3
	jmp	scan_instructions
      no_instruction:
	mov	esi,edx
	mov	ecx,ebp
	stc
	ret
      instruction_ok:
	mov	al,[ebx]
	mov	bx,[ebx+1]
	clc
	ret

get_label_id:
	cmp	ecx,0x100
	jae	name_too_long
	cmp	byte [esi],'.
	jne	standard_label
	cmp	byte [esi+1],'.
	je	standard_label
	cmp	dword [current_locals_prefix],0
	je	standard_label
	push	edi
	push	ecx
	push	esi
	mov	edi,dword [additional_memory]
	xor	al,al
	stosb
	mov	esi,dword [current_locals_prefix]
	mov	ebx,edi
	lodsb
	movzx	ecx,al
	lea	ebp,[edi+ecx]
	cmp	ebp,dword [additional_memory_end]
	jae	out_of_memory
	rep
	movsb
	pop	esi
	pop	ecx
	add	al,cl
	jc	name_too_long
	lea	ebp,[edi+ecx]
	cmp	ebp,dword [additional_memory_end]
	jae	out_of_memory
	rep
	movsb
	mov	dword [additional_memory],edi
	pop	edi
	push	esi
	movzx	ecx,al
	mov	esi,ebx
	call	get_label_id
	pop	esi
	ret
      standard_label:
	cmp	ecx,1
	jne	find_label
	lodsb
	cmp	al,'$
	je	get_current_offset_id
	cmp	al,'%
	je	get_counter_id
	dec	esi
	jmp	find_label
      get_current_offset_id:
	xor	eax,eax
	ret
      get_counter_id:
	mov	eax,1
	ret
      find_label:
	xor	ebx,ebx
	xor	eax,eax
	xor	ebp,ebp
      hash_label:
	movzx	eax,byte [esi+ebx]
	add	ebp,eax
	inc	bl
	cmp	bl,cl
	jb	hash_label
	shl	ebx,24
	or	ebp,ebx
	mov	dword [label_hash],ebp
	push	edi
	push	esi
	mov	ebx,esi
	mov	edx,ecx
	mov	eax,dword [labels_list]
      check_label:
	mov	esi,ebx
	mov	ecx,edx
	cmp	eax,dword [memory_end]
	je	add_label
	cmp	ebp,[eax]
	jne	next_label
	mov	edi,[eax+4]
	repe
	cmpsb
	je	label_found
      next_label:
	add	eax,16
	jmp	check_label
      label_found:
	add	esp,4
	pop	edi
	ret
      add_label:
	pop	esi
	cmp	byte [esi-1],0
	je	label_name_ok
	mov	al,[esi]
	cmp	al,0x30
	jb	name_first_char_ok
	cmp	al,0x39
	jbe	invalid_name
      name_first_char_ok:
	cmp	ecx,1
	jne	check_for_reserved_word
	cmp	al,'$
	je	reserved_word_used_as_symbol
      check_for_reserved_word:
	call	get_instruction
	jnc	reserved_word_used_as_symbol
	mov	edi,data_directives
	call	get_symbol
	jnc	reserved_word_used_as_symbol
	mov	edi,symbols
	call	get_symbol
	jnc	reserved_word_used_as_symbol
	mov	edi,formatter_symbols
	call	get_symbol
	jnc	reserved_word_used_as_symbol
      label_name_ok:
	mov	eax,dword [labels_list]
	sub	eax,16
	mov	dword [labels_list],eax
	mov	[eax+4],esi
	add	esi,ecx
	mov	edx,dword [label_hash]
	mov	[eax],edx
	pop	edi
	cmp	eax,edi
	jbe	out_of_memory
	ret

CASE_INSENSITIVE equ 0
;%define CASE_SENSITIVE

symbol_characters: db 25
 db 9,0xA,0xD,0x1A,0x20
 .ascii "+-/*:=|&~()[]<>{},;"
 db 0x5c  ; .ascii "\\"

operators:
 db 1
	.ascii "+"
	db 0x80
 db 1
	.ascii "-"
	db 0x81
 db 1
	.ascii "*"
	db 0x90
 db 1,'/,0x91
 ;db 1
;	.ascii "/"
;	db 0x91  ; Macro expansion bug in as86 0.11.0 and 0.12.0, fixed in 0.16.2.
 db 3
	.ascii "mod"
	db 0xA0
 db 3
	.ascii "and"
	db 0xB0
 db 2
	.ascii "or"
	db 0xB1
 db 3
	.ascii "xor"
	db 0xB2
 db 3
	.ascii "shl"
	db 0xC0
 db 3
	.ascii "shr"
	db 0xC1
 db 0

single_operand_operators:
 db 3
	.ascii "not"
	db 0xD0
 db 3
	.ascii "rva"
	db 0xE0
 db 0

directive_operators:
 db 2
	.ascii "at"
	db 0x80
 db 2
	.ascii "eq"
	db 0x81
 db 4
	.ascii "from"
	db 0x82
 db 2
	.ascii "in"
	db 0x83
 db 2
	.ascii "on"
	db 0x84
 db 0

address_registers:
 db 2
	.ascii "bp"
	db 0, 0x25
 db 2
	.ascii "bx"
	db 0, 0x23
 db 2
	.ascii "di"
	db 0, 0x27
 db 3
	.ascii "eax"
	db 0, 0x40
 db 3
	.ascii "ebp"
	db 0, 0x45
 db 3
	.ascii "ebx"
	db 0, 0x43
 db 3
	.ascii "ecx"
	db 0, 0x41
 db 3
	.ascii "edi"
	db 0, 0x47
 db 3
	.ascii "edx"
	db 0, 0x42
 db 3
	.ascii "esi"
	db 0, 0x46
 db 3
	.ascii "esp"
	db 0, 0x44
 db 2
	.ascii "si"
	db 0, 0x26
 db 0

address_sizes:
 db 4
	.ascii "byte"
	db 0, 1
 db 5
	.ascii "dword"
	db 0, 4
 db 4
	.ascii "word"
	db 0, 2
 db 0

symbols:
 db 2
	.ascii "ah"
	db 0x10, 0x14
 db 2
	.ascii "al"
	db 0x10, 0x10
 db 2
	.ascii "ax"
	db 0x10, 0x20
 db 2
	.ascii "bh"
	db 0x10, 0x17
 db 2
	.ascii "bl"
	db 0x10, 0x13
 db 2
	.ascii "bp"
	db 0x10, 0x25
 db 2
	.ascii "bx"
	db 0x10, 0x23
 db 4
	.ascii "byte"
	db 0x11, 1
 db 2
	.ascii "ch"
	db 0x10, 0x15
 db 2
	.ascii "cl"
	db 0x10, 0x11
 db 3
	.ascii "cr0"
	db 0x10, 0x50
 db 3
	.ascii "cr2"
	db 0x10, 0x52
 db 3
	.ascii "cr3"
	db 0x10, 0x53
 db 3
	.ascii "cr4"
	db 0x10, 0x54
 db 2
	.ascii "cs"
	db 0x10, 0x62
 db 2
	.ascii "cx"
	db 0x10, 0x21
 db 2
	.ascii "dh"
	db 0x10, 0x16
 db 2
	.ascii "di"
	db 0x10, 0x27
 db 2
	.ascii "dl"
	db 0x10, 0x12
 db 6
	.ascii "dqword"
	db 0x11, 16
 db 3
	.ascii "dr0"
	db 0x10, 0x70
 db 3
	.ascii "dr1"
	db 0x10, 0x71
 db 3
	.ascii "dr2"
	db 0x10, 0x72
 db 3
	.ascii "dr3"
	db 0x10, 0x73
 db 3
	.ascii "dr5"
	db 0x10, 0x75
 db 3
	.ascii "dr6"
	db 0x10, 0x76
 db 3
	.ascii "dr7"
	db 0x10, 0x77
 db 2
	.ascii "ds"
	db 0x10, 0x64
 db 5
	.ascii "dword"
	db 0x11, 4
 db 2
	.ascii "dx"
	db 0x10, 0x22
 db 3
	.ascii "eax"
	db 0x10, 0x40
 db 3
	.ascii "ebp"
	db 0x10, 0x45
 db 3
	.ascii "ebx"
	db 0x10, 0x43
 db 3
	.ascii "ecx"
	db 0x10, 0x41
 db 3
	.ascii "edi"
	db 0x10, 0x47
 db 3
	.ascii "edx"
	db 0x10, 0x42
 db 2
	.ascii "es"
	db 0x10, 0x61
 db 3
	.ascii "esi"
	db 0x10, 0x46
 db 3
	.ascii "esp"
	db 0x10, 0x44
 db 3
	.ascii "far"
	db 0x12, 2
 db 2
	.ascii "fs"
	db 0x10, 0x65
 db 5
	.ascii "fword"
	db 0x11, 6
 db 2
	.ascii "gs"
	db 0x10, 0x66
 db 3
	.ascii "mm0"
	db 0x10, 0x80
 db 3
	.ascii "mm1"
	db 0x10, 0x81
 db 3
	.ascii "mm2"
	db 0x10, 0x82
 db 3
	.ascii "mm3"
	db 0x10, 0x83
 db 3
	.ascii "mm4"
	db 0x10, 0x84
 db 3
	.ascii "mm5"
	db 0x10, 0x85
 db 3
	.ascii "mm6"
	db 0x10, 0x86
 db 3
	.ascii "mm7"
	db 0x10, 0x87
 db 4
	.ascii "near"
	db 0x12, 1
 db 5
	.ascii "pword"
	db 0x11, 6
 db 5
	.ascii "qword"
	db 0x11, 8
 db 2
	.ascii "si"
	db 0x10, 0x26
 db 2
	.ascii "sp"
	db 0x10, 0x24
 db 2
	.ascii "ss"
	db 0x10, 0x63
 db 2
	.ascii "st"
	db 0x10, 0x0A0
 db 3
	.ascii "st0"
	db 0x10, 0x0A0
 db 3
	.ascii "st1"
	db 0x10, 0x0A1
 db 3
	.ascii "st2"
	db 0x10, 0x0A2
 db 3
	.ascii "st3"
	db 0x10, 0x0A3
 db 3
	.ascii "st4"
	db 0x10, 0x0A4
 db 3
	.ascii "st5"
	db 0x10, 0x0A5
 db 3
	.ascii "st6"
	db 0x10, 0x0A6
 db 3
	.ascii "st7"
	db 0x10, 0x0A7
 db 5
	.ascii "tword"
	db 0x11, 0x0A
 db 5
	.ascii "use16"
	db 0x13, 0x10
 db 5
	.ascii "use32"
	db 0x13, 0x20
 db 4
	.ascii "word"
	db 0x11, 2
 db 4
	.ascii "xmm0"
	db 0x10, 0x90
 db 4
	.ascii "xmm1"
	db 0x10, 0x91
 db 4
	.ascii "xmm2"
	db 0x10, 0x92
 db 4
	.ascii "xmm3"
	db 0x10, 0x93
 db 4
	.ascii "xmm4"
	db 0x10, 0x94
 db 4
	.ascii "xmm5"
	db 0x10, 0x95
 db 4
	.ascii "xmm6"
	db 0x10, 0x96
 db 4
	.ascii "xmm7"
	db 0x10, 0x97
 db 0

formatter_symbols:
 if CASE_INSENSITIVE
 db 6
	.ascii "binary"
	db 0x18, 1
 db 4
	.ascii "code"
	db 0x19, 5
 db 7
	.ascii "console"
	db 0x1B, 3
 db 4
	.ascii "data"
	db 0x19, 6
 db 11
	.ascii "discardable"
	db 0x19, 25
 db 3
	.ascii "dll"
	db 0x1B, 0x80
 db 10
	.ascii "executable"
	db 0x19, 29
 db 6
	.ascii "export"
	db 0x1A, 0
 db 6
	.ascii "fixups"
	db 0x1A, 5
 db 3
	.ascii "gui"
	db 0x1B, 2
 db 4
	.ascii "i386"
	db 0x1B, 0x43
 db 4
	.ascii "i486"
	db 0x1B, 0x44
 db 4
	.ascii "i586"
	db 0x1B, 0x45
 db 6
	.ascii "import"
	db 0x1A, 1
 db 2
	.ascii "mz"
	db 0x18, 2
 db 6
	.ascii "native"
	db 0x1B, 1
 db 2
	.ascii "pe"
	db 0x18, 3
 db 8
	.ascii "readable"
	db 0x19, 30
 db 8
	.ascii "resource"
	db 0x1A, 2
 db 9
	.ascii "shareable"
	db 0x19, 28
 db 5
	.ascii "udata"
	db 0x19, 7
 db 9
	.ascii "writeable"
	db 0x19, 31
 else
 db 3
	.ascii "DLL"
	db 0x1B, 0x80
 db 3
	.ascii "GUI"
	db 0x1B, 2
 db 2
	.ascii "MZ"
	db 0x18, 2
 db 2
	.ascii "PE"
	db 0x18, 3
 db 6
	.ascii "binary"
	db 0x18, 1
 db 4
	.ascii "code"
	db 0x19, 5
 db 7
	.ascii "console"
	db 0x1B, 3
 db 4
	.ascii "data"
	db 0x19, 6
 db 11
	.ascii "discardable"
	db 0x19, 25
 db 10
	.ascii "executable"
	db 0x19, 29
 db 6
	.ascii "export"
	db 0x1A, 0
 db 6
	.ascii "fixups"
	db 0x1A, 5
 db 4
	.ascii "i386"
	db 0x1B, 0x43
 db 4
	.ascii "i486"
	db 0x1B, 0x44
 db 4
	.ascii "i586"
	db 0x1B, 0x45
 db 6
	.ascii "import"
	db 0x1A, 1
 db 6
	.ascii "native"
	db 0x1B, 1
 db 8
	.ascii "readable"
	db 0x19, 30
 db 8
	.ascii "resource"
	db 0x1A, 2
 db 9
	.ascii "shareable"
	db 0x19, 28
 db 5
	.ascii "udata"
	db 0x19, 7
 db 9
	.ascii "writeable"
	db 0x19, 31
 endif
 db 0

preprocessor_directives:
 db 7
	.ascii "include"
	dw  include_file-preprocessor

 db 5
	.ascii "macro"
	dw  define_macro-preprocessor

 db 5
	.ascii "purge"
	dw  purge_macro-preprocessor

 db 5
	.ascii "struc"
	dw  define_struc-preprocessor

 db 0

macro_directives:
 db 6
	.ascii "common"
	dw  common_block-preprocessor

 db 7
	.ascii "forward"
	dw  forward_block-preprocessor

 db 5
	.ascii "local"
	dw  local_symbols-preprocessor

 db 7
	.ascii "reverse"
	dw  reverse_block-preprocessor

 db 0

data_handlers:
 dw data_bytes-assembler
 dw data_file-assembler
 dw reserve_bytes-assembler
 dw data_words-assembler
 dw data_unicode-assembler
 dw reserve_words-assembler
 dw data_dwords-assembler
 dw reserve_dwords-assembler
 dw data_pwords-assembler
 dw reserve_pwords-assembler
 dw data_qwords-assembler
 dw reserve_qwords-assembler
 dw data_twords-assembler
 dw reserve_twords-assembler

data_directives:
 db 2
	.ascii "db"
	db 1, 0
 db 2
	.ascii "dd"
	db 4, 6
 db 2
	.ascii "dp"
	db 6, 8
 db 2
	.ascii "dq"
	db 8, 10
 db 2
	.ascii "dt"
	db 10, 12
 db 2
	.ascii "du"
	db 2, 4
 db 2
	.ascii "dw"
	db 2, 3
 db 4
	.ascii "file"
	db 1, 1
 db 2
	.ascii "rb"
	db 1, 2
 db 2
	.ascii "rd"
	db 4, 7
 db 2
	.ascii "rp"
	db 6, 9
 db 2
	.ascii "rq"
	db 8, 11
 db 2
	.ascii "rt"
	db 10, 13
 db 2
	.ascii "rw"
	db 2, 5
 db 0

instructions:
 dw instructions_2-instructions
 dw instructions_3-instructions
 dw instructions_4-instructions
 dw instructions_5-instructions
 dw instructions_6-instructions
 dw instructions_7-instructions
 dw instructions_8-instructions
 dw instructions_9-instructions
 dw instructions_10-instructions
 dw instructions_11-instructions

instructions_2:
 .ascii "bt"
	db 4
	dw  bt_instruction-assembler
 .ascii "if"
	db 0
	dw  if_directive-assembler
 .ascii "in"
	db 0
	dw  in_instruction-assembler
 .ascii "ja"
	db 0x77
	dw  conditional_jump-assembler
 .ascii "jb"
	db 0x72
	dw  conditional_jump-assembler
 .ascii "jc"
	db 0x72
	dw  conditional_jump-assembler
 .ascii "je"
	db 0x74
	dw  conditional_jump-assembler
 .ascii "jg"
	db 0x7F
	dw  conditional_jump-assembler
 .ascii "jl"
	db 0x7C
	dw  conditional_jump-assembler
 .ascii "jo"
	db 0x70
	dw  conditional_jump-assembler
 .ascii "jp"
	db 0x7A
	dw  conditional_jump-assembler
 .ascii "js"
	db 0x78
	dw  conditional_jump-assembler
 .ascii "jz"
	db 0x74
	dw  conditional_jump-assembler
 .ascii "or"
	db 0x8
	dw  basic_instruction-assembler
 db 0
instructions_3:
 .ascii "aaa"
	db 0x37
	dw  simple_instruction-assembler
 .ascii "aad"
	db 0xD5
	dw  aa_instruction-assembler
 .ascii "aam"
	db 0xD4
	dw  aa_instruction-assembler
 .ascii "aas"
	db 0x3F
	dw  simple_instruction-assembler
 .ascii "adc"
	db 0x10
	dw  basic_instruction-assembler
 .ascii "add"
	db 0x0
	dw  basic_instruction-assembler
 .ascii "and"
	db 0x20
	dw  basic_instruction-assembler
 .ascii "bsf"
	db 0xBC
	dw  bs_instruction-assembler
 .ascii "bsr"
	db 0xBD
	dw  bs_instruction-assembler
 .ascii "btc"
	db 7
	dw  bt_instruction-assembler
 .ascii "btr"
	db 6
	dw  bt_instruction-assembler
 .ascii "bts"
	db 5
	dw  bt_instruction-assembler
 .ascii "cbw"
	db 0x98
	dw  simple_instruction_16bit-assembler
 .ascii "cdq"
	db 0x99
	dw  simple_instruction_32bit-assembler
 .ascii "clc"
	db 0xF8
	dw  simple_instruction-assembler
 .ascii "cld"
	db 0xFC
	dw  simple_instruction-assembler
 .ascii "cli"
	db 0xFA
	dw  simple_instruction-assembler
 .ascii "cmc"
	db 0xF5
	dw  simple_instruction-assembler
 .ascii "cmp"
	db 0x38
	dw  basic_instruction-assembler
 .ascii "cwd"
	db 0x99
	dw  simple_instruction_16bit-assembler
 .ascii "daa"
	db 0x27
	dw  simple_instruction-assembler
 .ascii "das"
	db 0x2F
	dw  simple_instruction-assembler
 .ascii "dec"
	db 1
	dw  inc_instruction-assembler
 .ascii "div"
	db 6
	dw  single_operand_instruction-assembler
 .ascii "end"
	db 0
	dw  end_directive-assembler
 .ascii "hlt"
	db 0xF4
	dw  simple_instruction-assembler
 .ascii "inc"
	db 0
	dw  inc_instruction-assembler
 .ascii "ins"
	db 0
	dw  ins_instruction-assembler
 .ascii "int"
	db 0xCD
	dw  int_instruction-assembler
 .ascii "jae"
	db 0x73
	dw  conditional_jump-assembler
 .ascii "jbe"
	db 0x76
	dw  conditional_jump-assembler
 .ascii "jge"
	db 0x7D
	dw  conditional_jump-assembler
 .ascii "jle"
	db 0x7E
	dw  conditional_jump-assembler
 .ascii "jmp"
	db 0
	dw  jmp_instruction-assembler
 .ascii "jna"
	db 0x76
	dw  conditional_jump-assembler
 .ascii "jnb"
	db 0x73
	dw  conditional_jump-assembler
 .ascii "jnc"
	db 0x73
	dw  conditional_jump-assembler
 .ascii "jne"
	db 0x75
	dw  conditional_jump-assembler
 .ascii "jng"
	db 0x7E
	dw  conditional_jump-assembler
 .ascii "jnl"
	db 0x7D
	dw  conditional_jump-assembler
 .ascii "jno"
	db 0x71
	dw  conditional_jump-assembler
 .ascii "jnp"
	db 0x7B
	dw  conditional_jump-assembler
 .ascii "jns"
	db 0x79
	dw  conditional_jump-assembler
 .ascii "jnz"
	db 0x75
	dw  conditional_jump-assembler
 .ascii "jpe"
	db 0x7A
	dw  conditional_jump-assembler
 .ascii "jpo"
	db 0x7B
	dw  conditional_jump-assembler
 .ascii "lar"
	db 2
	dw  lar_instruction-assembler
 .ascii "lds"
	db 3
	dw  ls_instruction-assembler
 .ascii "lea"
	db 0
	dw  lea_instruction-assembler
 .ascii "les"
	db 0
	dw  ls_instruction-assembler
 .ascii "lfs"
	db 4
	dw  ls_instruction-assembler
 .ascii "lgs"
	db 5
	dw  ls_instruction-assembler
 .ascii "lsl"
	db 3
	dw  lar_instruction-assembler
 .ascii "lss"
	db 2
	dw  ls_instruction-assembler
 .ascii "mov"
	db 0
	dw  mov_instruction-assembler
 .ascii "mul"
	db 4
	dw  single_operand_instruction-assembler
 .ascii "neg"
	db 3
	dw  single_operand_instruction-assembler
 .ascii "nop"
	db 0x90
	dw  simple_instruction-assembler
 .ascii "not"
	db 2
	dw  single_operand_instruction-assembler
 .ascii "org"
	db 0
	dw  org_directive-assembler
 .ascii "out"
	db 0
	dw  out_instruction-assembler
 .ascii "pop"
	db 0
	dw  pop_instruction-assembler
 .ascii "rcl"
	db 2
	dw  sh_instruction-assembler
 .ascii "rcr"
	db 3
	dw  sh_instruction-assembler
 .ascii "rep"
	db 0xF3
	dw  prefix_instruction-assembler
 .ascii "ret"
	db 0xC2
	dw  ret_instruction-assembler
 .ascii "rol"
	db 0
	dw  sh_instruction-assembler
 .ascii "ror"
	db 1
	dw  sh_instruction-assembler
 .ascii "rsm"
	db 0xAA
	dw  simple_extended_instruction-assembler
 .ascii "sal"
	db 6
	dw  sh_instruction-assembler
 .ascii "sar"
	db 7
	dw  sh_instruction-assembler
 .ascii "sbb"
	db 0x18
	dw  basic_instruction-assembler
 .ascii "shl"
	db 4
	dw  sh_instruction-assembler
 .ascii "shr"
	db 5
	dw  sh_instruction-assembler
 .ascii "stc"
	db 0xF9
	dw  simple_instruction-assembler
 .ascii "std"
	db 0xFD
	dw  simple_instruction-assembler
 .ascii "sti"
	db 0xFB
	dw  simple_instruction-assembler
 .ascii "sub"
	db 0x28
	dw  basic_instruction-assembler
 .ascii "ud2"
	db 0xB
	dw  simple_extended_instruction-assembler
 .ascii "xor"
	db 0x30
	dw  basic_instruction-assembler
 db 0
instructions_4:
 .ascii "arpl"
	db 0
	dw  arpl_instruction-assembler
 .ascii "call"
	db 0
	dw  call_instruction-assembler
 .ascii "clts"
	db 6
	dw  simple_extended_instruction-assembler
 .ascii "cmps"
	db 0
	dw  cmps_instruction-assembler
 .ascii "cwde"
	db 0x98
	dw  simple_instruction_32bit-assembler
 .ascii "else"
	db 0
	dw  else_directive-assembler
 .ascii "heap"
	db 0
	dw  heap_directive-assembler
 .ascii "idiv"
	db 7
	dw  single_operand_instruction-assembler
 .ascii "imul"
	db 0
	dw  imul_instruction-assembler
 .ascii "int3"
	db 0xCC
	dw  simple_instruction-assembler
 .ascii "into"
	db 0xCE
	dw  simple_instruction-assembler
 .ascii "invd"
	db 8
	dw  simple_extended_instruction-assembler
 .ascii "iret"
	db 0xCF
	dw  simple_instruction-assembler
 .ascii "jcxz"
	db 0xE3
	dw  loop_instruction_16bit-assembler
 .ascii "jnae"
	db 0x72
	dw  conditional_jump-assembler
 .ascii "jnbe"
	db 0x77
	dw  conditional_jump-assembler
 .ascii "jnge"
	db 0x7C
	dw  conditional_jump-assembler
 .ascii "jnle"
	db 0x7F
	dw  conditional_jump-assembler
 .ascii "lahf"
	db 0x9F
	dw  simple_instruction-assembler
 .ascii "load"
	db 0
	dw  load_directive-assembler
 .ascii "lock"
	db 0xF0
	dw  prefix_instruction-assembler
 .ascii "lods"
	db 0
	dw  lods_instruction-assembler
 .ascii "loop"
	db 0xE2
	dw  loop_instruction-assembler
 .ascii "movs"
	db 0
	dw  movs_instruction-assembler
 .ascii "outs"
	db 0
	dw  outs_instruction-assembler
 .ascii "popa"
	db 0x61
	dw  simple_instruction-assembler
 .ascii "popf"
	db 0x9D
	dw  simple_instruction-assembler
 .ascii "push"
	db 0
	dw  push_instruction-assembler
 .ascii "repe"
	db 0xF3
	dw  prefix_instruction-assembler
 .ascii "repz"
	db 0xF3
	dw  prefix_instruction-assembler
 .ascii "retd"
	db 0xC2
	dw  ret_instruction_32bit-assembler
 .ascii "retf"
	db 0xCA
	dw  ret_instruction-assembler
 .ascii "retn"
	db 0xC2
	dw  ret_instruction-assembler
 .ascii "retw"
	db 0xC2
	dw  ret_instruction_16bit-assembler
 .ascii "sahf"
	db 0x9E
	dw  simple_instruction-assembler
 .ascii "scas"
	db 0xAE
	dw  stos_instruction-assembler
 .ascii "seta"
	db 0x97
	dw  set_instruction-assembler
 .ascii "setb"
	db 0x92
	dw  set_instruction-assembler
 .ascii "setc"
	db 0x92
	dw  set_instruction-assembler
 .ascii "sete"
	db 0x94
	dw  set_instruction-assembler
 .ascii "setg"
	db 0x9F
	dw  set_instruction-assembler
 .ascii "setl"
	db 0x9C
	dw  set_instruction-assembler
 .ascii "seto"
	db 0x90
	dw  set_instruction-assembler
 .ascii "setp"
	db 0x9A
	dw  set_instruction-assembler
 .ascii "sets"
	db 0x98
	dw  set_instruction-assembler
 .ascii "setz"
	db 0x94
	dw  set_instruction-assembler
 .ascii "shld"
	db 0xA4
	dw  shd_instruction-assembler
 .ascii "shrd"
	db 0xAC
	dw  shd_instruction-assembler
 .ascii "stos"
	db 0xAA
	dw  stos_instruction-assembler
 .ascii "test"
	db 0
	dw  test_instruction-assembler
 .ascii "wait"
	db 0x9B
	dw  simple_instruction-assembler
 .ascii "xadd"
	db 0xC0
	dw  basic_486_instruction-assembler
 .ascii "xchg"
	db 0
	dw  xchg_instruction-assembler
 .ascii "xlat"
	db 0xD7
	dw  xlat_instruction-assembler
 db 0
instructions_5:
 .ascii "bound"
	db 0
	dw  bound_instruction-assembler
 .ascii "bswap"
	db 0
	dw  bswap_instruction-assembler
 .ascii "cmpsb"
	db 0xA6
	dw  simple_instruction-assembler
 .ascii "cmpsd"
	db 0
	dw  cmpsd_instruction-assembler
 .ascii "cmpsw"
	db 0xA7
	dw  simple_instruction_16bit-assembler
 .ascii "cpuid"
	db 0xA2
	dw  simple_extended_instruction-assembler
 .ascii "enter"
	db 0
	dw  enter_instruction-assembler
 .ascii "entry"
	db 0
	dw  entry_directive-assembler
 .ascii "fwait"
	db 0x9B
	dw  simple_instruction-assembler
 .ascii "iretd"
	db 0xCF
	dw  simple_instruction_32bit-assembler
 .ascii "iretw"
	db 0xCF
	dw  simple_instruction_16bit-assembler
 .ascii "jecxz"
	db 0xE3
	dw  loop_instruction_32bit-assembler
 .ascii "label"
	db 0
	dw  label_directive-assembler
 .ascii "leave"
	db 0xC9
	dw  simple_instruction-assembler
 .ascii "lodsb"
	db 0xAC
	dw  simple_instruction-assembler
 .ascii "lodsd"
	db 0xAD
	dw  simple_instruction_32bit-assembler
 .ascii "lodsw"
	db 0xAD
	dw  simple_instruction_16bit-assembler
 .ascii "loopd"
	db 0xE2
	dw  loop_instruction_32bit-assembler
 .ascii "loope"
	db 0xE1
	dw  loop_instruction-assembler
 .ascii "loopw"
	db 0xE2
	dw  loop_instruction_16bit-assembler
 .ascii "loopz"
	db 0xE1
	dw  loop_instruction-assembler
 .ascii "movsb"
	db 0xA4
	dw  simple_instruction-assembler
 .ascii "movsd"
	db 0
	dw  movsd_instruction-assembler
 .ascii "movsw"
	db 0xA5
	dw  simple_instruction_16bit-assembler
 .ascii "movsx"
	db 0xBE
	dw  movx_instruction-assembler
 .ascii "movzx"
	db 0xB6
	dw  movx_instruction-assembler
 .ascii "popad"
	db 0x61
	dw  simple_instruction_32bit-assembler
 .ascii "popaw"
	db 0x61
	dw  simple_instruction_16bit-assembler
 .ascii "popfd"
	db 0x9D
	dw  simple_instruction_32bit-assembler
 .ascii "popfw"
	db 0x9D
	dw  simple_instruction_16bit-assembler
 .ascii "pusha"
	db 0x60
	dw  simple_instruction-assembler
 .ascii "pushf"
	db 0x9C
	dw  simple_instruction-assembler
 .ascii "repne"
	db 0xF2
	dw  prefix_instruction-assembler
 .ascii "repnz"
	db 0xF2
	dw  prefix_instruction-assembler
 .ascii "retfd"
	db 0xCA
	dw  ret_instruction_32bit-assembler
 .ascii "retfw"
	db 0xCA
	dw  ret_instruction_16bit-assembler
 .ascii "retnd"
	db 0xC2
	dw  ret_instruction_32bit-assembler
 .ascii "retnw"
	db 0xC2
	dw  ret_instruction_16bit-assembler
 .ascii "scasb"
	db 0xAE
	dw  simple_instruction-assembler
 .ascii "scasd"
	db 0xAF
	dw  simple_instruction_32bit-assembler
 .ascii "scasw"
	db 0xAF
	dw  simple_instruction_16bit-assembler
 .ascii "setae"
	db 0x93
	dw  set_instruction-assembler
 .ascii "setbe"
	db 0x96
	dw  set_instruction-assembler
 .ascii "setge"
	db 0x9D
	dw  set_instruction-assembler
 .ascii "setle"
	db 0x9E
	dw  set_instruction-assembler
 .ascii "setna"
	db 0x96
	dw  set_instruction-assembler
 .ascii "setnb"
	db 0x93
	dw  set_instruction-assembler
 .ascii "setnc"
	db 0x93
	dw  set_instruction-assembler
 .ascii "setne"
	db 0x95
	dw  set_instruction-assembler
 .ascii "setng"
	db 0x9E
	dw  set_instruction-assembler
 .ascii "setnl"
	db 0x9D
	dw  set_instruction-assembler
 .ascii "setno"
	db 0x91
	dw  set_instruction-assembler
 .ascii "setnp"
	db 0x9B
	dw  set_instruction-assembler
 .ascii "setns"
	db 0x99
	dw  set_instruction-assembler
 .ascii "setnz"
	db 0x95
	dw  set_instruction-assembler
 .ascii "setpe"
	db 0x9A
	dw  set_instruction-assembler
 .ascii "setpo"
	db 0x9B
	dw  set_instruction-assembler
 .ascii "stack"
	db 0
	dw  stack_directive-assembler
 .ascii "stosb"
	db 0xAA
	dw  simple_instruction-assembler
 .ascii "stosd"
	db 0xAB
	dw  simple_instruction_32bit-assembler
 .ascii "stosw"
	db 0xAB
	dw  simple_instruction_16bit-assembler
 .ascii "times"
	db 0
	dw  times_directive-assembler
 .ascii "xlatb"
	db 0xD7
	dw  simple_instruction-assembler
 db 0
instructions_6:
 .ascii "format"
	db 0
	dw  format_directive-assembler
 .ascii "looped"
	db 0xE1
	dw  loop_instruction_32bit-assembler
 .ascii "loopew"
	db 0xE1
	dw  loop_instruction_16bit-assembler
 .ascii "loopne"
	db 0xE0
	dw  loop_instruction-assembler
 .ascii "loopnz"
	db 0xE0
	dw  loop_instruction-assembler
 .ascii "loopzd"
	db 0xE1
	dw  loop_instruction_32bit-assembler
 .ascii "loopzw"
	db 0xE1
	dw  loop_instruction_16bit-assembler
 .ascii "pushad"
	db 0x60
	dw  simple_instruction_32bit-assembler
 .ascii "pushaw"
	db 0x60
	dw  simple_instruction_16bit-assembler
 .ascii "pushfd"
	db 0x9C
	dw  simple_instruction_32bit-assembler
 .ascii "pushfw"
	db 0x9C
	dw  simple_instruction_16bit-assembler
 .ascii "repeat"
	db 0
	dw  repeat_directive-assembler
 .ascii "setalc"
	db 0xD6
	dw  simple_instruction-assembler
 .ascii "setnae"
	db 0x92
	dw  set_instruction-assembler
 .ascii "setnbe"
	db 0x97
	dw  set_instruction-assembler
 .ascii "setnge"
	db 0x9C
	dw  set_instruction-assembler
 .ascii "setnle"
	db 0x9F
	dw  set_instruction-assembler
 db 0
instructions_7:
 .ascii "loopned"
	db 0xE0
	dw  loop_instruction_32bit-assembler
 .ascii "loopnew"
	db 0xE0
	dw  loop_instruction_16bit-assembler
 .ascii "loopnzd"
	db 0xE0
	dw  loop_instruction_32bit-assembler
 .ascii "loopnzw"
	db 0xE0
	dw  loop_instruction_16bit-assembler
 .ascii "virtual"
	db 0
	dw  virtual_directive-assembler
 db 0
instructions_8:
 db 0
instructions_9:
 db 0
instructions_10:
 db 0
instructions_11:
 db 0

;%include done

_copyright: .ascii "Copyright (c) 1999-2002, Tomasz Grysztar"
	db 0

_logo: .ascii "flat assembler  version "
	.ascii "1.30-bootstrap"  ; VERSION_STRING. No way for equ.
	db 10, 0  ; .ascii "\n\0"

_usage: .ascii "usage: fasm source output"
	db 10, 0  ; .ascii "\n\0"

_passes_suffix: .ascii " passes, "
	db 0
_seconds_suffix: .ascii " seconds, "
	db 0
_bytes_suffix: .ascii " bytes."
	db 10, 0  ; .ascii "\n\0"

_counter: db 4  ; .ascii "\004"
	.ascii "0000"

prebss:
; Make sure that the 5 bytes \xff\0\0\0 added by as86 <=0.0.6 won't be used
; even if the Linux kernel maps the entire file to memory. This gurantees
; that bss (from `bss:') is zero-initialized.
skip_5_bytes: rmb 5
bss_align equ (file_header-prebss)&3
;.bss  ; Works but not needed by as8 0.0.5.
bss: rmb bss_align  ; Uninitialized data follows.

memory_start: rmb 4
memory_end: rmb 4
additional_memory: rmb 4
additional_memory_end: rmb 4
input_file: rmb 4
output_file: rmb 4
source_start: rmb 4
code_start: rmb 4
code_size: rmb 4
real_code_size: rmb 4
start_time: rmb 4
written_size: rmb 4

current_line: rmb 4
macros_list: rmb 4
macro_constants: rmb 4
macro_block: rmb 4
macro_block_line_number: rmb 4
struc_name: rmb 4
current_locals_prefix: rmb 4
labels_list: rmb 4
label_hash: rmb 4
org_start: rmb 4
org_sib: rmb 4
undefined_data_start: rmb 4
undefined_data_end: rmb 4
counter: rmb 4
counter_limit: rmb 4
error_line: rmb 4
error: rmb 4
display_buffer: rmb 4
structures_buffer: rmb 4
number_start: rmb 4
current_offset: rmb 4
value: rmb 8
fp_value: rmb 8
format_flags: rmb 4
number_of_relocations: rmb 4
number_of_sections: rmb 4
stub_size: rmb 4
header_data: rmb 4
sections_data: rmb 4
current_section: rmb 4
machine: rmb 2
subsystem: rmb 2
subsystem_version: rmb 4

macro_status: rmb 1
parenthesis_stack: rmb 1
output_format: rmb 1
code_type: rmb 1
current_pass: rmb 1
next_pass_needed: rmb 1
reloc_labels: rmb 1
times_working: rmb 1
virtual_data: rmb 1
fp_sign: rmb 1
fp_format: rmb 1  ; TODO(pts): Remove unused variables.
value_size: rmb 1
forced_size: rmb 1
value_type: rmb 1
address_size: rmb 1
compare_type: rmb 1
base_code: rmb 1
extended_code: rmb 1
postbyte_register: rmb 1
segment_register: rmb 1
operand_size: rmb 1
imm_sized: rmb 1
jump_type: rmb 1
mmx_size: rmb 1
mmx_prefix: rmb 1
nextbyte: rmb 1

characters: rmb 0x100
converted: rmb 0x100
available_memory: rmb 4

program_end:

; __END__
