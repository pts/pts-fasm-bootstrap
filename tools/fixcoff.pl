#!/bin/sh --
eval 'PERL_BADLANG=x;export PERL_BADLANG;exec perl -x "$0" "$@";exit 1'
#!perl  # Start marker used by perl -x.
+0 if 0;eval("\n\n\n\n".<<'__END__');die$@if$@;__END__

#
# fixcoff.pl: fix i386 COFF object file generated by old assemblers, converting it to PE/COFF (pe-i386) for modern tools
# by pts@fazekas.hu at Sun Apr  7 19:48:40 CEST 2024
#
# More info about the COFF object file format: https://wiki.osdev.org/COFF
#
# COFF object files generated by the following assemblers are supported:
#
# * the Coherent assembler as(1), same as Mark Williams 80386 assembler (mw386as)
# * the SVR3 assembler as(1), idas(1)
# * the SunOS 4.0.1 assembler as(1)
# * (not tried yet) MinGW32 GNU Binutils assembler i586-mingw32msvc-as, i686-w64-mingw32-as
# * (not tried yet) NASM (`-f win32`; maybe also `-f coff`)
# * (not tried yet) Yasm (`-f win32`; maybe also `-f coff`)
# * (not tried yet) fasm `format ms coff` and `format coff`
# * (not tried yet) JWasm `-coff` (there is also `-win64` for amd64 64-bit COFF, which is not supported)
# * (not tried yet) ASMC `-coff` (there is also `-win64` for amd64 64-bit COFF, which is not supported)
# * (not tried yet) MASM (>=6.1) `/coff`
#
# The following linkers will be able to use the PE/COFF object file after
# the fix:
#
# * the GNU Binutils linker ld(1) producing Linux (and FreeBSD etc.) i386 ELF-32 executables
# * the MinGW32 GNU Binutils linker i586-mingw32msvc-as, i686-w64-mingw32-as
# * OpenWatcom linker wlink(1) producing Linux i386 ELF-32 or Win32 executables
# * (not tried yet) LADSoft CC386 VALX linker producing Win32, LE or LX executables
# * (not tried yet) ALINK linker producing Win32 executables
# * (not tried yet) Microsoft linker (>=6.00) link.exe
#
# The following tools will be able to analyze the the PE/COFF object file
# after the fix:
#
# * GNU Binutils objdump(1) etc.
# * MinGW32 GNU Binutils i586-mingw32msvc-objdump, i686-w64-mingw32-objdmup
# * Coherent COFF dump tool cdmp(1): it works even before the fix
# * (not tried yet) OpenWatcom dump tool wdump(1)
# * OpenWatcom disassembler wdis(1)
# * (not tried yet) Microsoft linker (>=6.00) link.exe
#
# Please note that GNU Binutils objdump(1) ignores the .comment section in a
# COFF .o file.
#
# Questions to answer:
#
# * What is the difference between classic (iBCS2) COFF, DJGPP COFF and PE/COFF?
# * Does COFF support the .rodata section? Which assemblers support it?
#

BEGIN { $^W = 1 }
use integer;
use strict;

if (!@ARGV or $ARGV[0] eq "--help") {
  print STDERR "Usage: $0 [<flag> ...] <filename.o>\n";
  exit(!@ARGV);
}
# TODO(pts): Add error handling for get_int.
sub get_int($) { lc(substr($_[0], 0, 2)) eq "0x" ? hex(substr($_[0], 2)) : substr($_[0], 0, 1) eq "0" ? oct($_[0]) : int($_[0]) }
my $do_fewer = 0;
my($fn, $timdat);
{ my $i;
  for ($i = 0; $i < @ARGV; ++$i) {
    my $arg = $ARGV[$i];
    if ($arg eq "--") { ++$i; last }
    elsif (substr($arg, 0, 1) ne "-") { last }
    elsif ($arg eq "--fewer") { $do_fewer = 1 }   # Make fewer changes.
    elsif ($arg =~ m@\A--timdat=(.*)@s) { $timdat = get_int($1) }   # Set timdat (timestamp) in the header. Useful for reproducible builds.
    else { die "fatal: unknown command-line flag: $arg\n" }
  }
  die "fatal: missing <filename.o> argument\n" if $i >= @ARGV;
  $fn = $ARGV[$i++];
  die "fatal: too many command-line arguments\n" if $i > @ARGV;
}

sub fnopenq($) { $_[0] =~ m@[-+.\w]@ ? $_[0] : "./" . $_[0] }
die "fatal: error opening: $fn\n" if !open(F, "+< " . fnopenq($fn));
binmode(F);
{ my $oldfd = select(F); $| = 1; select($oldfd); }  # Autoflush.
my $s;
die "fatal: object file to short: $fn\n" if read(F, $s, 0xb4) < 0xb4 - 0x28;
my $sh = vec($s, 0, 16);
if ($sh != 0x4c01) {  # Check in big endian.
  die "fatal: previous fix has crashed, regenerate file: $fn\n" if $sh == 0xffff;
  die "fatal: not a COFF object file: $fn\n";
}
my $section_count = unpack("v", substr($s, 2, 2));
die "fatal: must have 3 or 4 sections: $fn\n" if $section_count != 3 and $section_count != 4;
#die "fatal: must have 3 sections: $fn\n" if $section_count != 3;  # .rodata would be next, but that's not supported by mw386as or SVR3 assembler or SunOS 4.01 assembler.
die "fatal: EOF in COFF section definitions: $fn\n" if length($s) < 0x14 + ($section_count * 0x28);
die "fatal: expected .text section" if substr($s, 0x1c - 8, 8) ne ".text\0\0\0";
die "fatal: expected .data section" if substr($s, 0x44 - 8, 8) ne ".data\0\0\0";
die "fatal: expected .bss section" if substr($s, 0x6c - 8, 8) ne ".bss\0\0\0\0";
#die "fatal: expected .rodata section" if $section_count >= 4 and substr($s, 0x94 - 8, 8) ne ".rodata\0";  # .rodata is not supported by mw386as or SVR3 assembler or SunOS 4.01 assembler.
die "fatal: expected .rodata section" if $section_count >= 4 and substr($s, 0x94 - 8, 8) ne ".comment";

# --- Fix the file header.

sub max {
  die "fatal: assert: no input to max(...)\n" if !@_;
  my $result = $_[0];
  for my $v (@_) {
    $result = $v if $result < $v;
  }
  $result
}

# https://stackoverflow.com/questions/78287296/binutils-objdump-reports-incorrect-section-sizes-in-coff-object
my $s0 = $s;
substr($s, 4, 4) = pack("V", $timdat) if defined($timdat);
vec($s, 0x12, 8) &= ~2;  # byte 0x12 &= ~1;  # EXECUTABLE. OpenWatcom wlink(1) fails with `invalid object file attribute' if set.
#vec($s, 0x12, 8) |= 4;  # byte 0x12 |= 4;  # LINES_STRIPPED. Doesn't matter. `nasm -f coff' output has it, `nasm -f win32' output doesn't have it.
vec($s, 0x13, 8) |= 1;  # byte 0x13 |= 1;  # F_AR32WR. 32-bit little endian.
vec($s, 0x38 + 2, 8) |= 0x30;
vec($s, 0x38 + 3, 8) |= 0x60;  # dword 0x38 0x20 -> 0x60300020  # .text flags.
vec($s, 0x60 + 2, 8) |= 0x30;
vec($s, 0x60 + 3, 8) |= 0xc0;  # dword 0x60 0x40 -> 0xc0300040  # .data flags.
vec($s, 0x88 + 2, 8) |= 0x30;
vec($s, 0x88 + 3, 8) |= 0xc0;  # dword 0x88 0x80 -> 0xc0300080  # .bss flags.
vec($s, 0xb0 + 2, 8) |= 0x30 if $section_count >= 4;
vec($s, 0xb0 + 3, 8) |= 0x40 if $section_count >= 4;  # dword 0xb0 0x40 -> 0x40300040  # .rodata flags. (.rdata by MinGW as(1).)
my($text_vaddr, $text_size) = unpack("VV", substr($s, 0x1c + 4, 8));
vec($s, 0x1c >> 2, 32) = 0 if !$do_fewer;  # .text paddr.  # Already 0.
vec($s, 0x20 >> 2, 32) = 0 if !$do_fewer;  # .text vaddr.  # Already 0.
my $text_ofs = unpack("V", substr($s, 0x1c + 0xc, 4));
my $text_reloc_ofs = unpack("V", substr($s, 0x1c + 0x10, 4));
my $text_reloc_count = unpack("V", substr($s, 0x1c + 0x18, 4));
my($data_vaddr, $data_size) = unpack("VV", substr($s, 0x44 + 4, 8));
vec($s, 0x44 >> 2, 32) = 0 if !$do_fewer;  # .data paddr.
vec($s, 0x48 >> 2, 32) = 0 if !$do_fewer;  # .data vaddr.
my $data_ofs = unpack("V", substr($s, 0x44 + 0xc, 4));
my $data_reloc_ofs = unpack("V", substr($s, 0x44 + 0x10, 4));
my $data_reloc_count = unpack("V", substr($s, 0x44 + 0x18, 4));
my($bss_vaddr, $bss_size) = unpack("VV", substr($s, 0x6c + 4, 8));
my $comment_vaddr = 0;
$comment_vaddr = unpack("V", substr($s, 0x94 + 4, 4)) if $section_count == 4;
vec($s, 0x6c >> 2, 32) = 0 if !$do_fewer;  # .bss paddr. By keeping it, .bss size is wrong.
vec($s, 0x70 >> 2, 32) = 0 if !$do_fewer;  # .bss vaddr. By keeping it, .bss size is wrong.
#vec($s, 0x94 >> 2, 32) = 0 if !$do_fewer and $section_count >= 4;  # .rodata paddr.
#vec($s, 0x98 >> 2, 32) = 0 if !$do_fewer and $section_count >= 4;  # .rodata vaddr.
my $is_coff_fixed = ($text_vaddr == 0 and $data_vaddr == 0 and $bss_vaddr == 0);
my($sym_ofs, $sym_count) = unpack("VV", substr($s, 8, 8));
my $end_ofs = max($sym_ofs + $sym_count * 0x12, $text_reloc_ofs + $text_reloc_count * 10, $data_reloc_ofs + $data_reloc_count * 10, ($text_size ? $text_ofs + $text_size : 0), ($data_size ? $data_ofs + $data_size : 0));
die if !seek(F, 0, 2);
my $fsize = tell(F);
my $is_coff_large = ($fsize - 4 >= $end_ofs);  # OpenWatcom wdump(1) fails unless there are trailing bytes.
exit(0) if $s0 eq $s and $is_coff_large;  # Already correct.
vec($s, 0, 16) = 0xffff if !($is_coff_fixed and $is_coff_large);  # Ruin the file header temporarily, in case the process crashes before finishing successfully.
die if !seek(F, 0, 0);
die if !print(F $s);
if ($is_coff_fixed and $is_coff_large) {
  die if !close(F);
  exit(0);
}

# --- Fix the symbol table.

my @sec_vaddrs = (0, $text_vaddr, $data_vaddr, $bss_vaddr, $comment_vaddr);
my($text_sym, $data_sym, $bss_sym);
my $zvaddr_count = 0;
my %extern_symbols;
if (!$is_coff_fixed) {
  die if !seek(F, $sym_ofs, 0);
  my $ss;
  my $ss_has_changed = 0;
  die "fatal: error reading symbol table\n" if (read(F, $ss, $sym_count * 0x12) or 0) != $sym_count * 0x12;
  for (my $i = 0; $i < $sym_count; ) {  # https://web.archive.org/web/20230921074944/https://delorie.com/djgpp/doc/coff/symtab.html
    my($name, $value, $scnum, $type, $sclass, $numaux) = unpack("a8VvvCC", substr($ss, $i * 0x12, 0x12));
    $name =~ s@\0+\Z(?!\n)@@;
    # Names longer than 8 bytes are added later. We don't need them. $name is empty for them.
    #printf STDERR "info: symbol name=%s value=0x%x scnum=0x%x type=0x%x sclass=0x%x numaux=0x%x\n", $name, $value, $scnum, $type, $sclass, $numaux;
    my $i0 = $i;
    $i += $numaux + 1;
    $extern_symbols{$i0} = 1 if !$scnum;  # External symbol.
    next if !$scnum or $scnum == 0xffff or $scnum == 0x0fffe;  # External symbol or absolute value or debug symbol (such as .file).
    my $is_section = 0;
    if    ($name eq ".text" and $scnum == 1 and $type == 0 and $sclass == 3) { $is_section = 1; ++$zvaddr_count if !$value; die "fatal: bad .text value\n" if $value != $text_vaddr and $value != 0; $text_sym = $i0 }
    elsif ($name eq ".data" and $scnum == 2 and $type == 0 and $sclass == 3) { $is_section = 1; ++$zvaddr_count if !$value; die "fatal: bad .data value\n" if $value != $data_vaddr and $value != 0; $data_sym = $i0 }
    elsif ($name eq ".bss"  and $scnum == 3 and $type == 0 and $sclass == 3) { $is_section = 1; ++$zvaddr_count if !$value; die "fatal: bad .bss value\n"  if $value != $bss_vaddr  and $value != 0; $bss_sym = $i0 }
    die "fatal: unexpected scnum: $scnum\n" if $scnum != 1 and $scnum != 2 and $scnum != 3 and $scnum != 4;
    if ($is_section ? ($value != 0) : ($sec_vaddrs[$scnum] != 0 and $zvaddr_count != 3)) {  # (This doesn't work with .rodata.).
      $ss_has_changed = 1;
      # Making it -$value would make linking with OpenWatcom wlink(1) fail.
      substr($ss, $i0 * 0x12 + 8, 4) = pack("V", $is_section ? 0 : $value - $sec_vaddrs[$scnum]);  # Fix symbol value.
    }
  }
  # TODO(pts): Make it work with a few sections missing.
  die "fatal: missing sections in symbol table\n" if !defined($text_sym) or !defined($data_sym) or !defined($bss_sym);
  if ($ss_has_changed) {
    die if !seek(F, $sym_ofs, 0);
    die if !print(F $ss);
  }
}

# --- Fix the relocations.

sub fix_relocs($$$$$) {
  my($reloc_ofs, $count, $sec_ofs, $sec_vaddr, $sec_size) = @_;
  return if $count == 0;
  die "fatal: relocation count overflow\n" if $count < 0 or $count >= 214748364;  # Should be OK even if multiplied by 10.
  die "fatal: relocation ofs overflow\n" if $reloc_ofs < 0 or ($reloc_ofs >> 31) != 0;
  $count *= 10;
  my $r;
  die if !seek(F, $reloc_ofs, 0);
  die if read(F, $r, $count) != $count;
  my $r_has_changed = 0;
  for (my $i = 0; $i != $count; $i += 10) {
    my($vaddr, $symndx, $type) = unpack("VVv", substr($r, $i, 10));
    # RELOC_ADDR32=6, RELOC_REL32=0x14==20.
    #printf(STDERR "info: reloc sec_vaddr=0x%x vaddr=0x%x symndx=0x%x type=0x%x\n", $sec_vaddr, $vaddr, $symndx, $type);
    my $delta = 0;
    if ($type == 0x14 and $symndx == $text_sym) {  # IP-relative relocation emitted by the SVR3 assembler for `call' and `jmp'.
      # !! Is this still buggy? It looks like the wrong byte have been overwritten. Is the SVR3 assembler buggy? See bug1.txt
      $delta = $vaddr + 4;  # For modern linkers.
    } else {
      die sprintf("fatal: expected reloc type=0x6(RELOC_ADDR32) at vaddr=0x%x, got 0x%x\n", $vaddr, $type) if $type != 6;
      die sprintf("fatal: bad symndx: 0x%x\n", $symndx) if $symndx < 0 or $symndx >= $sym_count;
      die sprintf("fatal: bad vaddr: sec_vaddr=0x%x sec_size=0x%x vaddr=0x%x\n", $sec_vaddr, $sec_size, $vaddr) if $vaddr < $sec_vaddr or $vaddr + 4 > $sec_vaddr + $sec_size;
      if (!$do_fewer and $sec_vaddr != 0) { substr($r, $i, 4) = pack("V", $vaddr - $sec_vaddr); $r_has_changed = 1 }
      my $sec_idx = ($symndx == $text_sym ? 1 : $symndx == $data_sym ? 2 : $symndx == $bss_sym ? 3 : 0);
      if (!$sec_idx) {  # Not a section-based relocation.
        die "fatal: unexpected symndx: $symndx\n" if !exists($extern_symbols{$symndx});  # What to do if not an external symbol? Should we do the subtraction of the symbol value?
        die "fatal: invalid symndx: $symndx\n" if $symndx <= $bss_sym;
        next;
      }
      next if $zvaddr_count == 3;  # Running non---fewer after previous run with --fewer. (This doesn't work with .rodata.)
      $delta = -$sec_vaddrs[$sec_idx];
    }
    #my $d0;
    #die if !seek(F, $sec_ofs + $vaddr - $sec_vaddr, 0);
    #die if read(F, $d0, 4) != 4;
    #printf(STDERR "info: reloc vaddr=0x%x delta=-0x%x, symndx=0x%x type=0x%x d=0x%x\n", $vaddr, -$delta & 0xffffffff, $symndx, $type, unpack("V", $d0));
    next if $delta == 0;
    #printf(STDERR "info: fix vaddr=0x%x delta=-0x%x\n", $vaddr, -$delta & 0xffffffff);
    my $d;
    die if !seek(F, $sec_ofs + $vaddr - $sec_vaddr, 0);
    die if read(F, $d, 4) != 4;
    my $d2 = pack("V", (unpack("V", $d) + $delta) & 0xffffffff);
    #printf(STDERR "info: fix vaddr=0x%x delta=-0x%x d=0x%x d2=0x%x\n", $vaddr - $sec_vaddr, -$delta & 0xffffffff, unpack("V", $d), unpack("V", $d2));
    die if !seek(F, $sec_ofs + $vaddr - $sec_vaddr, 0);
    die if !print(F $d2);
  }
  if ($r_has_changed) {
    die if !seek(F, $reloc_ofs, 0);
    die if !print(F $r);
  }
}

if (!$is_coff_fixed) {
  fix_relocs($text_reloc_ofs, $text_reloc_count, $text_ofs, $text_vaddr, $text_size);
  fix_relocs($data_reloc_ofs, $data_reloc_count, $data_ofs, $data_vaddr, $data_size);
}

# ---

if (!$is_coff_large) {
  die if !seek(F, 0, 2);
  my $extra = "\0" x ($end_ofs - ($fsize - 4));  # Typically $end_ofs == $fsize, so it's 4.
  die if !print(F $extra);
}

die if !seek(F, 0, 0);
$s = "\0\0"; vec($s, 0, 16) = 0x4c01;  # Big endian.
die if !print(F $s);
die if !close(F);

__END__
